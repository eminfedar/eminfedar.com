{"componentChunkName":"component---src-templates-tags-js","path":"/tags/RAM","result":{"pageContext":{"posts":{"RAM":[{"excerpt":"Merhabalar! Bu yazımızda RAM’imizi tasarlamayı bitiriyoruz. Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efenim. Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efendim. RAM…","html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizi tasarlamayı bitiriyoruz.</p>\n<p><img src=\"static/img/ram/buzz-eriste.jpeg\" alt=\"Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efenim.\"> <br><em>Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efendim.</em></p>\n<h2>RAM’imizin içini adım adım tasarlayalım:</h2>\n<ol>\n<li>Adres girişlerinden aldığımız sayıyı 4. Yazıda ele aldığımız <a href=\"0-dan-ram-4-kod-cozuculer\">Kod Çözücüleri</a> kullanarak iki boyutlu <a href=\"0-dan-ram-5-ram-hucresi\">Ram Hücreleri</a> matrisi hazırlayalım.</li>\n<li>Bu matrisin içine hücrelerimizi yerleştirip hücrenin “<strong>EN</strong>”<em>(aktif etme)</em> ucunu iki kod çözücüden gelen seçim uçlarına “<strong>VE</strong>” kapısı ile bağlayacağız. *(Mesela <strong>0. satır</strong> ve <strong>4. sütun</strong> seçim uçları <strong>aktif ise</strong> (0, 4)'teki hücreyi aktif et)*</li>\n<li>RAM’e erişimin okumak için mi yazmak için mi olduğunu öğrendiğimiz <strong>R/W’</strong> girişini bütün <strong>hücrelerin R/W</strong>’ girişlerine <strong>teker teker</strong> bağlayacağız.</li>\n<li>Seçtiğimiz RAM hücresinden veriyi okuyacağımız veya yazacağımız pin olan <strong>I/O</strong> (Giriş/Çıkış) pinini de bütün <strong>hücrelerin I/O</strong> girişine bağlayacağız.</li>\n<li>Chip Select girişini ise direkt olarak bütün girişlerle VE kapılayabiliriz ama bu biraz uzun ve gereksiz bir uğraş olur gibi.\nOnun yerine; eğer gerçekten yapacak olsaydık, decoder gibi komponentlerimizin VCC ve GND uçları olacağından sadece VCC uçlarını VE kapılayabilirdik. <em>(yani çipe elektriği verip vermeme şeklinde bir anahtarlama olabilir.)</em>\n<em>(O yüzden CS pini görselde bir yere bağlı değil :))</em></li>\n</ol>\n<p><img src=\"static/img/ram/ram-full.png\" alt=\"4000x4000 çözünürlüğe sahip RAMcik içi.\">\n<br><em>4000x4000 çözünürlüğe sahip RAMcik içi.</em></p>\n<p>Bütün bunları sırasıyla yaptığımızda karşımızda RAM’imiz için 8 tanesini yan yana getireceğimiz 256 boyutunda 1 bit saklayabilen <strong>“RAMcik”</strong>leri elde ederiz :).</p>\n<p>(😲)</p>\n<div style=\"width: 100%; height: 0px; position: relative; padding-bottom: 100.000%;\"><iframe src=\"https://streamable.com/s/xwc8s/nrcvlh\" frameborder=\"0\" width=\"100%\" height=\"100%\" allowfullscreen style=\"width: 100%; height: 100%; position: absolute;\"></iframe></div>\n<p><a href=\"https://streamable.com/xwc8s\">> HD Video</a></p>\n<p>Şema olarak RAM’imizden tek farkı veri çıkışında sadece 1 tane pin olması. <em>(Çünkü 256 farklı adres için sadece 1 bit saklayan hücrelerden oluşuyor)</em></p>\n<p>Bu 256 farklı adreste 1 bit saklayan “RAMcik”lerimizden 8 tane yan yana getirip, veri çıkışlarını da yüksek önemli bitten düşük önemli bite göre bağlayıp CS ve R’/W uçlarını da RAM’in CS ve R’/W uçlarına bağlar isek, 256x8'lik bir RAM yapmış oluruz.</p>\n<p><img src=\"static/img/ram/ram-son-hal.gif\" alt=\"Ve RAM!\"></p>\n<h2>Ve RAM!</h2>\n<p>Tebrikler!</p>\n<p>6 yazılık bu bloğu okuyup anlayarak kendi RAM’inizi sıfırdan tasarlamayı öğrendiniz. <em>(her yiğidin harcı değil )</em></p>\n<p><img src=\"static/img/ram/congrats.jpeg\" alt=\"Tebrikler!\"><br><em>Tebrikler!</em></p>\n<blockquote>\n<p>Eğer babanızdan kalma fabrika zincirleriniz varsa veya milyoner bir iş adamıysanız bu bilgiler üzerine biraz daha koyarak (256 Byte yetmez şimdi tabi, bunu nano seviyede küçültüp 8GB yi sığdırmanız lazım oraya :)) gerçek ve elle tutulur bir RAM yapıp ülkeye güzel bir ihracat geliri getirebilirsiniz :)</p>\n</blockquote>\n<p>Veya kişisel çaplı projelerde kullanılmak üzere (mesela bir arduino projesi) modül olarak takılabilir bir RAM yapıp insanlara sunabilirsiniz. <em>(veya satabilirsiniz :))</em></p>\n<blockquote>\n<p>Tabi bu işin de kendince standartları var, bizim yaptığımız RAM tamamen kendi standartlarımız ve tercihlerimize dayalı oldu.</p>\n</blockquote>\n<h2>Bundan Sonra</h2>\n<p>Daha da derinlere inip bu işin ehli olmak isterseniz inceleyebileceğiniz birkaç wikipedia linki ekleyelim:</p>\n<p>RAM çeşitleri olarak <a href=\"https://www.wikiwand.com/en/Static_random-access_memory\">SRAM</a>, <a href=\"https://www.wikiwand.com/en/Dynamic_random-access_memory\">DRAM</a>.\n<em>(RAM var RAM var, hepsi aynı değil tabi)</em></p>\n<p>İşlemci ile RAM’in arasındaki iletişim standartları olarak ise<a href=\"https://www.wikiwand.com/en/Double_data_rate\"> SDR, DDR, QDR</a> gibi konulara bakabilirsiniz.\n<em>(Gözünüz korkmasın, bunlar sadece belirli standartlar, çok farklı ve gelişmiş şeyler değil, buraya kadar geldiyseniz bunları da kolayca anlayabilirsiniz.)</em></p>\n<p>Günleriniz ve ömrünüz bol bereketli ve hayırlı olsun.\n<br> <strong>İyi günler.</strong></p>","id":"cce30859-a23d-5d5c-bee0-6adb5f5ab6c3","frontmatter":{"date":"Mart 07, 2020","description":"Ve RAM'imizin son hali :)","image":"static/img/ram/kapak-ram6.png","path":"/0-dan-ram-6-ram-hucresi","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 6) Ve RAM!"}},{"excerpt":"Merhabalar! Bu yazımızda RAM’imizin iç devresini tasarlamaya başlayacağız. Atacağım devre dosyaları Logisim programından olacak. Tamamen sıfırdan kendi RAM’inizi inşa edip, simüle edip test…","html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizin iç devresini tasarlamaya başlayacağız. Atacağım devre dosyaları <a href=\"https://sourceforge.net/projects/circuit/\"><strong>Logisim</strong></a> programından olacak. Tamamen sıfırdan kendi RAM’inizi inşa edip, simüle edip test edebileceksiniz :)</p>\n<h2>RAM’imiz nasıl bir şey olacak?</h2>\n<p>RAM’imizin iç devresini tasarlamadan önce içi hazır bir eleman olarak düşünüp sadece giriş ve çıkışlarını tasarlayalım. <strong>Yani genel hatlarını belli edelim.</strong></p>\n<p>RAM’imiz <strong>2⁸x8</strong> boyutlarında olacak. Buradaki ilk değer RAM’in içindeki <strong>hücre</strong> sayısıdır. Yani 2⁸ tane <strong>çekmeceden</strong> oluşan bir dolap gibi düşünülebilir.</p>\n<p>İkinci değer (8) ise her çekmecenin içinde saklanan bit sayısıdır.</p>\n<p>Yani 2⁸=256 tane hücremiz var, her hücrede de 8 bit saklıyoruz.</p>\n<blockquote>\n<p>Dolayısıyla RAM’imiz <strong>2048</strong> adet <strong>0</strong> veya <strong>1</strong> saklıyor\n<strong>8 bit = 1 byte</strong> olduğundan <strong>256 Byte</strong>’lık bir RAM’imiz olacak.</p>\n</blockquote>\n<p>Eğer 1GB’lık bir RAM yapmak isteseydik:</p>\n<p><strong>1GB için 2³⁰x8</strong><br>\n<strong>2GB için 2³¹x8</strong><br>\n<strong>4GB için 2³²x8</strong>\nbir RAM tasarlayacaktık.</p>\n<p>32 bit işlemcilerin olduğu sistemlere 4GB’dan fazla RAM <strong>takılamamasının</strong> sebebi en fazla <strong>2 üzeri 32'ye</strong> kadar adres tutabilmesidir. Yani 2³²’den ekstra 1 tanecik fazla da olsa hücreyi adresleyemez, veriyi saklayamaz, tanımlayamaz, saklaması için 33. yeni bir bite ihtiyacı var.</p>\n<p>64 bit sistemler ise 2⁶⁴ yani <strong>“18 446 744 073 709 551 616 Byte”</strong> hafızaya sahip olacak kadar adresleme yapabilir, bu da yaklaşık <strong>“17 179 869 184 GB”</strong> yapıyor :) <em>(4GB’ye göre gerçekten yüksek bir rakam)</em></p>\n<blockquote>\n<p>Yani 64 bit işlemciye sahip bir bilgisayarınız varsa 17 Milyar GB RAM’e kadar yükseltme yapabilirsiniz (tabi gerçek hayatta adres tutmak için 64 bitin hepsi ayrılmaz :))</p>\n</blockquote>\n<h3>RAM Çipimizin Genel Tasarımı</h3>\n<p><img src=\"static/img/ram/ram-chip.png\" alt=\"RAM Çipimizin Genel Tasarımı.\"></p>\n<p><em>RAM Çipimizin Genel Tasarımı.</em></p>\n<p><strong>Y:</strong> Yüksek Değerlikli Bit (<strong>2⁷</strong>)<br>\n<strong>D:</strong> Düşük Değerlikli Bit (<strong>2⁰</strong>)<br>\n<strong>CS (Chip Select):</strong> RAM çipimizi aktif eden giriş.<br>\n<strong>R’/W:</strong> Okuma yapmak için <strong>0 (R’)</strong> Yazma yapmak için <strong>1 (W)</strong> değeri verilmesi gereken girişimiz.</p>\n<p>--</p>\n<p>Çipimiz tamam, peki işlemci ile veri alışverişini nasıl sağlayacak? Çıkışları direk işlemciye mi bağlayacağız? Eğer öyle ise her yaptığımız eleman için işlemcide ayrı ayrı çıkışların mı olması gerek?</p>\n<h3>Veri Aktarım Yöntemi</h3>\n<p>Normal şartlarda iki şekilde bir çipi başka bir çip ile haberleştirebilirsiniz:</p>\n<p><strong>1.</strong> Direkt olarak birinin <strong>çıkışlarını</strong> diğerinin <strong>girişlerine</strong> bağlarsınız</p>\n<p><strong>2.</strong> İki veya daha fazla çipi ortak bir tane veri yoluna bağlayıp, <strong>Çip Seçim</strong> girişleri ile sadece konuşturmak istediğiniz çipleri aktif ederek veri aktarımını sağlarsınız.</p>\n<p><em>(Örneğin SSD’den veri okuyacağım, o zaman SSD’yi aktif edip diğerlerini pasif halde tutarım. Veya RAM’den veri okumak istiyorum, diğerlerini pasif hale getirip bu sefer de sadece RAM’i aktif ederim)</em></p>\n<p><img src=\"static/img/ram/common-data-bus.gif\" alt=\"Ortak veri yolu kullanan çiplerin Chip Select girişi kullanılarak veri yoluna bağlanması.\">\n<br><em>Ortak veri yolu kullanan çiplerin Chip Select girişi kullanılarak veri yoluna bağlanması.</em></p>\n<h2>Gelelim artık RAM Hücresine!</h2>\n<p>Güzel bir söz var:</p>\n<blockquote>\n<p><strong>\"Baharı icad etmeyen, bir elmayı icad edemez. Zira o elma, o tezgâhta dokunuyor. Bir elmayı icad eden, bir baharı icad edebilir…\"</strong></p>\n</blockquote>\n<p>Bunun RAM ile alakası ise;</p>\n<blockquote>\n<p>Milyarlarca biti saklayabilmek için önce 1 biti saklayabilmek gerek,\n1 biti saklayamayan milyarları saklayamaz.\nMilyarları saklayabilen 1 biti saklayabilendir.</p>\n</blockquote>\n<p>Yani önce <strong>tek bir biti saklayabilen</strong> bir <strong>“RAM Hücresi”</strong> yapıp sonra bunu istediğimiz sayıda kopyalarak istediğimiz boyutta RAM elde edeceğiz.</p>\n<p><img src=\"static/img/ram/ram-cell.gif\" alt=\"Ramimize 1 bitlik veri saklama işini gerçekleştirecek temel RAM Hücresi. İç planı ve dışarıya soyutlanmış halleri.\">\n<br> <em>Ramimize 1 bitlik veri saklama işini gerçekleştirecek temel RAM Hücresi. İç planı ve dışarıya soyutlanmış halleri.</em></p>\n<p>Hücremizin içinde kullandığımız devrede ilginç bir eleman görebilirsiniz. <em>(D Q ve CLK yazan)</em></p>\n<p>Bu eleman ilk derste gösterdiğim <strong>AND-OR-LATCHE</strong> yani Ve-Veya Mandalı’nın birazcık daha değişik hali.</p>\n<blockquote>\n<p>Ve-Veya mandalı <strong>SET</strong> kısmına 1 verilince verimiz <strong>1</strong>\n<strong>Reset</strong> kısmına 1 verilince verimiz <strong>0</strong> oluyordu.</p>\n</blockquote>\n<p>Biz ise Set-Reset mantığı yerine,<strong>hangi veriyi verirsek onu saklayan</strong> bir mandal <em>( veya daha gelişmişi: Flip/Flop )</em> istiyoruz.</p>\n<p><strong>D-Tipi</strong> Flip Floplar da bu görevi gerçekleştiriyor.</p>\n<p>Merak etmeyin, baştaki mandalımıza <strong>2 VE</strong> ve <strong>1 Değil</strong> kapısı ekleyerek D-Tipi F/F elde edebiliriz.</p>\n<p>Logisim programında tasarladığım çalışan bir D-Tipi F/F’nin görüntüsü şu şekilde: <em>(yani RAM hücremizin içindeki D Q ve CLK yazan devre elemanının içi)</em></p>\n<p><img src=\"static/img/ram/logisim-d-ff.png\" alt=\"D-Tipi F/F iç devresi\"> <br>\n<a href=\"https://shorturl.at/kyDOY\">Logisim programında çalışan bir D tipi F/F devre dosyası</a></p>\n<blockquote>\n<p>Kırmızı çizgi ile ayırdığım kısmın sağında kalan parçalar ilk dersimizdeki <strong>Ve-Veya</strong> mandalı. Ek olarak sadece soldaki <strong>2 tane VE, 1 tane Değil</strong> kapılarını ekledik.</p>\n</blockquote>\n<p><strong>Bu bağlantıları neye göre yapacağımızı</strong> ve hangi kapıları ekleyeceğimizi D-Tipi F/F’lerin doğruluk tablosunu çizerek kendiniz de elde edebilirsiniz. <em>(ipucu olarak Data ve CLK girişlerine karşılık Set ve Reset çıkışlarının durumları tablosunu kullanarak devreyi elde edebilirsiniz.)</em></p>\n<h2>RAM Hücremiz tamam. Hadi şimdi bununla bir RAM yapalım!</h2>\n<p>Bu yazı hem biraz uzun oldu, hem de RAM’in direkt olarak iç dizaynını ayrı bir yazıda ele almak amacıyla <em>(tüm her şey tek bir yazıda toplanıp çorba gibi olmasın, ayrı ayrı düzenli olsun)</em> en iyisi bir sonraki yazıya bırakalım :)</p>\n<p>Serimizin son yazısı olacağını tahmin ettiğim <a href=\"0-dan-ram-6-ve-ram\">0 → RAM | 6) Ve RAM!</a> Yazımızda görüşmek üzere.</p>\n<p>Esenlikler ve mutluluklar içinde kalınız.<br>\nSelamün aleyküm.</p>","id":"b18792b7-1dc2-5bcc-8e8f-be868cc1ed80","frontmatter":{"date":"Mart 06, 2020","description":"Temel RAM bileşenlerimizin sonuncusu \"Kod Çözücüler\"","image":"static/img/ram/kapak-ram5.png","path":"/0-dan-ram-5-ram-hucresi","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 5) RAM Hücresi"}},{"excerpt":"Merhabalar! Bu yazımızda RAM’imizin içindeki belirli adreslere erişmek için devremizde kullanacağımız Kod Çözücüleri ve Kodlayıcıları ele alacağız. Kod Çözücüler ne işe yarar? Bir Kod Çözücü kısaca…","html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizin içindeki belirli adreslere erişmek için devremizde kullanacağımız <strong>Kod Çözücüleri</strong> ve <strong>Kodlayıcıları</strong> ele alacağız.</p>\n<h2>Kod Çözücüler ne işe yarar?</h2>\n<p>Bir Kod Çözücü kısaca: <strong>seçim elemanıdır.</strong></p>\n<p>Girişlerine ikilik tabanda verilen girdiye göre sadece bir çıkışını aktif eder. Örneğin <strong>2 girişli</strong> ve <strong>4 çıkışlı</strong> (2x4) bir Kod Çözücü aşağıdaki gibi çalışır:</p>\n<blockquote>\n<p>00 -> <strong>0</strong></p>\n<p>01 -> <strong>1</strong></p>\n<p>10 -> <strong>2</strong></p>\n<p>11 -> <strong>3</strong></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*XHlRexbJWrW9BobgAUxDtQ.gif\" alt=\"2 Giriş, 4 Çıkışlı bir kod çözücünün çalışma şekli.\"></p>\n<p><em>2 Giriş, 4 Çıkışlı bir kod çözücünün çalışma şekli.</em></p>\n<p>Gördüğünüz gibi burada decoderin(kod çözücünün) iç devre tasarımı yok, bize sadece giriş ve çıkış uçları olan bir devre elemanı olarak verilmiş.</p>\n<p>Bu olaya <strong>abstraction</strong> yani <strong>soyutlama</strong> denir.</p>\n<p>Çoğu zaman yaptığımız ve bir işlevi gerçekleştirebilen küçük devreleri her seferinde tekrardan çizmeyiz. Bir kere çizdikten sonra onları bir eleman haline getirip sonra çoğaltarak istediğimiz kadar kullanırız. <em>(Bu düstur yazılımda da sıkça kullanılmaktadır)</em></p>\n<p>Fakat biz yine de kendi decoderimizi de yapmayı öğrenebilmek adına içine bir göz atalım :)</p>\n<p><em>Aslında gayet basit bir iç devresi var.</em></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*N3XCDp5dOmWpUfCdqYm0Hg.gif\" alt=\"2x4 Kod Çözücünün içi.\"><em>2x4 Kod Çözücünün içi.</em></p>\n<p>Siz de kolayca çıkışlarımızın mantıksal durumlarını yazarak devreyi rahatlıkla bulabilirdiniz. Nitekim biz de öyle yaptık:</p>\n<blockquote>\n<p>Y0= X1’.X0’ (00)</p>\n<p>Y1= X1’.X0 (01)</p>\n<p>Y2= X1.X0’ (10)</p>\n<p>Y3= X1.X0 (11)</p>\n</blockquote>\n<h3>“İyi güzel de, bu RAM yaparken ne işimize yarayacak?”</h3>\n<p>Eğer yazılım ile uğraşıyorsanız, özellikle C/C++ gibi adreslemelerin <em>(pointer)</em> bolca kullanıldığı dillerde tanımladığınız <strong>değişkenlerin</strong> bir <strong>adresi</strong> olduğunu fark etmişsinizdir.</p>\n<p>Bu adres genelde <strong>0x123456</strong> şeklinde onaltılık tabanda gösterilen bir sayı olur ve değişkeninizdeki <strong>verinin</strong> RAMinizde 0x123456 nolu bellek hücresinde tutulduğunu belirtir.</p>\n<h3>Mesela:</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*ZUdJocmCbepWUyJnPSk-5w.png\" alt=\"a isminde bir değişkenin RAM’deki bir hücrede saklanması.\"></p>\n<p><em>a isminde bir değişkenin RAM’deki bir hücrede saklanması.</em></p>\n<h3>İşte tam burada kod çözücüler devreye giriyor.</h3>\n<p>Bilgisayarda tüm işlemlerimiz İkilik (Binary) sistemde, yani 0 veya 1.</p>\n<p>0x100002 nolu hücreye erişebilmek için <strong>örneğin 4GB</strong>’lik bir RAM’de <strong>4,294,967,296</strong> tane hücreden <strong>sadece 1 tanesini</strong> seçip okumamız/yazmamız gerek ve bunu ikilik sistemde çalışan işlemcimizden aldığımız bitler ile yapabilmeliyiz.</p>\n<p>Kod Çözücüler ise seçim elemanlarıydı ve tam da aradığımız gibi; girişlerine ikilik sistemden bir sayı alıp, çıkışlarından sadece o sayıya karşılık gelen çıkışı aktif hale getiriyordu.</p>\n<p>Bu şekilde eğer bir Kod çözücüye <strong>2³² = 4,294,967,296</strong> hesabıyla <strong>32 giriş</strong> ve <strong>4,294,967,296</strong> farklı çıkış verirsek tüm hücrelere rahatlıkla erişebiliriz değil mi?</p>\n<h3>Aslında pek de sayılmaz :)</h3>\n<p>4,294,967,296 tane kabloyu teker teker bir hücreye bağlamak hem kablo, hem alan hem de işlem israfı olacaktır. Bu yüzden tek boyutlu olarak düşündüğümüz hücreleri adresleme işlemini iki boyutlu düşünmeliyiz. Yani 1 boyutlu bir dizi değil de, 2 boyutlu bir Matris olarak hücrelerimizi tutmalıyız.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*-KvuViSro2avKO3wtKrXww.gif\" alt=\"2 boyutlu matris kullanarak daha az kablo kullanımını sağlamak.\"><em>2 boyutlu matris kullanarak daha az kablo kullanımını sağlamak.</em></p>\n<p>4GB’lik bir RAM için ise 2³² şeklinde tek bir decoder yerine, 2⁸’lik 4 tane decoder kullanılabilir. Böylece kablo sayısı 4,294,967,296'dan 128'e düşüyor. Bu da bize <strong>33 milyon kat</strong> daha az kablo kullanımı ile muazzam bir tasarruf sağlıyor.</p>\n<h2>Kod çözücüler de tamam!</h2>\n<p>Artık RAM yapabilmek için temel bileşenlerin çoğunun çalışma şeklini biliyoruz.</p>\n<p>Şimdi geriye bu bileşenleri kullanarak bir RAM tasarlamak kaldı.</p>\n<p>Bir sonraki yazımız olan <strong><a href=\"0-dan-ram-5-ram-hucresi\">0 → RAM | 5) RAM Hücresi</a></strong>'inde görüşmek üzere!</p>","id":"46b74bd1-d671-5a63-8562-d70a94ae6ec4","frontmatter":{"date":"Mart 05, 2020","description":"Temel RAM bileşenlerimizin sonuncusu \"Kod Çözücüler\"","image":"static/img/ram/kapak-ram4.png","path":"/0-dan-ram-4-kod-cozuculer","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 4) Kod Çözücüler"}},{"excerpt":"Merhabalar! Önceki derste Mantık Kapılarına ve Doğruluk Tablolarına giriş yapmıştık. Doğruluk Tabloları güzeldi fakat bir eksiği vardı ki; kapı sayısı arttıkça Doğruluk Tablolarının çekilemez…","html":"<h2>Merhabalar!</h2>\n<p>Önceki derste <strong>Mantık Kapıları</strong>na ve <strong>Doğruluk Tabloları</strong>na giriş yapmıştık. Doğruluk Tabloları güzeldi fakat bir eksiği vardı ki; kapı sayısı arttıkça <strong>Doğruluk Tabloları</strong>nın çekilemez uzunluklara ulaşması ve sadeleştirme işlemlerinin biraz daha zor görülmesiydi.</p>\n<p>İşte bu sıkıntıları çekmemek için Maurice Karnaugh ve Edward Veitch’in güzel bir çalışması olan Karnaugh (Karnaugh-Veitch) Haritalarını kullanacağız.</p>\n<h2>Karnaugh Haritaları (Karnaugh-Veitch Maps)</h2>\n<p>Karnaugh Haritaları basitçe doğruluk tablosunun aşağıya doğru uzayan hali yerine <strong>iki boyutlu bir tablo</strong> haline getirilmesinden ibaret. <strong>Fakat bize sağladığı kolaylıklar çok fazla. :)</strong></p>\n<h3>Bir örnek yapalım:</h3>\n<p>Örneğimiz bir toplayıcı devresi olsun. Devremizde <strong>Bit-1</strong>, <strong>Bit-2</strong> butonları (girişleri) ve <strong>SONUÇ</strong> ve <strong>ELDE</strong> çıkışları (buralara LED bağlayabiliriz) olsun.</p>\n<p>Gireceğimiz iki biti toplayan ve eğer <strong>elde <em>(carry)</em></strong> değeri elde edersek <strong>ELDE</strong> çıkışını 1 yapan <em>(amma çok elde kelimesi geçti… :))</em>, toplama sounucunu da <strong>SONUÇ</strong> çıkışına veren bir devre yapalım. Bu devrenin doğruluk tablosunu çizersek şöyle bir sonuç elde ederiz:</p>\n<p><img src=\"static/img/ram/half-adder-tablosu.png\" alt=\"Yarım Toplayıcı(Half-Adder) Doğruluk Tablosu\"><em>Yarım Toplayıcı(Half-Adder) Doğruluk Tablosu</em></p>\n<p><strong>“Sonuç”</strong> çıkışı görebileceğimiz üzere bir <strong>Özel VEYA</strong> (XOR) kapısı ile gerçeklenebilir, çünkü sadece tet bir bit <strong>1</strong> olduğu zaman çıkış <strong>1</strong>.</p>\n<blockquote>\n<p>XOR: ⊕</p>\n<p>XNOR: ⊙</p>\n</blockquote>\n<p><strong>“Elde”</strong> çıkışımız ise sadece iki bit de 1 olduğu zaman 1 oluyor. O halde Elde çıkışı bir <strong>VE</strong> kapısı ile gerçeklenebilir. Bu durumda devremizin Sonuç çıkışının mantık kapılarıyla formülünü çıkarmak istersek:</p>\n<blockquote>\n<p><strong>Sonuç</strong> = <strong>b1 ⊕ b2</strong></p>\n<p><strong>Elde</strong> = <strong>b1 . b2</strong></p>\n</blockquote>\n<p>Tebrikler, bir <strong>Yarım Toplayıcı</strong> yaptınız :)</p>\n<h2>İyi de neden “Yarım” oldu ki?</h2>\n<p><img src=\"static/img/ram/half-adder.gif\" alt=\"Yarım Toplayıcı (Half-Adder) devresi\"></p>\n<p><em>Yarım Toplayıcı (Half-Adder) devresi</em></p>\n<p>Bu devreye “<strong>Yarım Toplayıcı</strong>” denilmesinin sebebi işleme bir önceki sonucun eldesini katmıyor olması. Devre çıkış olarak ELDE veriyor, fakat giriş olarak başka bir toplayıcıdan gelen ELDE’yi <strong>dikkate almıyor</strong>.</p>\n<p>O halde <strong>girişlerimize</strong> de bir <strong>ELDE</strong> ekleyip <strong>TAM</strong> bir toplayıcı yapalım :)</p>\n<p><strong>Tam Toplayıcının doğruluk tablosunu çizersek</strong>:</p>\n<p><img src=\"static/img/ram/full-adder-tablosu.png\" alt=\"b1, b2 ve Elde girişine sahip tam toplayıcının doğruluk tablosu\"></p>\n<p><em>b1, b2 ve Elde girişine sahip tam toplayıcının doğruluk tablosu</em></p>\n<p><em>(eveeet işler biraz karıştı değil mi :))</em></p>\n<p><strong>Sonuç</strong> ve <strong>Elde</strong> çıkışlarımızda 1'ler biraz karışık şekilde dağılmış. Örneğin yarım toplayıcıdaki gibi <strong>“Sonuç”</strong> çıkışı için hangi kapı veya kapılar gerekir kestiremiyoruz.</p>\n<h3>O zaman Karnaugh!</h3>\n<p><img src=\"static/img/ram/full-adder-karna.gif\" alt=\"Sonuç ve Elde çıkışlarımızı elde etmek için kullandığımız Karnaugh Haritaları\"></p>\n<p><em>Sonuç ve Elde çıkışlarımızı elde etmek için kullandığımız Karnaugh Haritaları</em></p>\n<p><strong>Elde</strong> ve <strong>Sonuç</strong> çıkışları için; <strong>b1</strong>, <strong>b2</strong> ve <strong>E</strong> girişlerine göre <strong>Karnaugh Haritası</strong> çizersek yukarıdaki gibi iki tane harita elde ederiz.</p>\n<p><em>(Karnaugh’da her çıkış için ayrı tablo çizilir.)</em></p>\n<p>Önemli NOT:</p>\n<blockquote>\n<p>Karnaugh’da sütun veya satırlar sırayla <strong>00–01–10–11</strong> şeklinde <strong>DEĞİL</strong>, <strong>GrayCode</strong> dizilimi olan ve bir sonraki durumla arasında sadece 1 bit fark olan <strong>00–01–11–10</strong> formatında yazılır.\n<strong>GrayCode</strong> formatına göre eğer bir satırda üç tane değişkenimiz olsaydı: <strong>000–001–011–010–110–111–101–100</strong> şeklinde yazacaktık. (iki durum arası sadece 1 bit farklı.)</p>\n</blockquote>\n<h3>Haritanın üzerine niye kutular çizdik ki?</h3>\n<p>Karnaugh Haritalarını özel kılan şey de bu.</p>\n<p>Doğruluk Tablosunda göremediğimiz “1'ler arasındaki ilişkiyi” burada gözle görebiliyoruz, bu da bize <strong>1'leri gruplandırıp</strong>, aynı sonucu verecek devre için <strong>fazladan</strong> kullanacağımız elemanlardan kurtulabilmemizi sağlıyor.</p>\n<p>Mesela <strong>ELDE</strong>’nin haritasındaki mavi kutuyu düşünelim. E b1 b2 sırasıyla yazarsam 101 ve 111 aynı sonucu veriyor <em>(yani 1)</em>. Yani ortadaki değerin (b1) 0 veya 1 olması sonucu etkilemiyor. Bu yüzden b1 girişini devreye katmayıp, <strong>E</strong> ve <strong>b2</strong>'yi bir <strong>VE</strong> kapısına bağlıyoruz.</p>\n<h3>Peki neyi sadeleştirdi bu?</h3>\n<p>Eğer b1'i de kaale alsaydık aynı sonucu elde edebilen şöyle bir devre kurabilirdik:</p>\n<blockquote>\n<p>ELDE = E.<strong>(b1.b2 + b1’.b2)</strong> + …</p>\n</blockquote>\n<p>Halbuki Karnaugh sayesinde yukarıda 5 kapı kullanırken, sadeleştirdiğimiz sonuçta 2 kapı kullanıyoruz:</p>\n<blockquote>\n<p>ELDE = <strong>E.b2</strong> + …</p>\n</blockquote>\n<h2>“ELDE” tablosundaki yan yana üç tane 1'i neden bir grup yapıp daha fazla sadeleştirme yapmadık?</h2>\n<p>Karnaugh Haritalarıda gruplama yaparken elbette belirli kurallarımız var, gruplama yaparken bu kurallara göre yapıyoruz:</p>\n<blockquote>\n<p>*Sadece <strong>2ᶰ katları</strong> kadar 1'ler <strong>gruplanabilir:*</strong></p>\n</blockquote>\n<p><img src=\"static/img/ram/karna-kural1.gif\" alt=\"*Sadece **2ᶰ katları** kadar 1&#x27;ler **gruplanabilir**.*\"></p>\n<blockquote>\n<p>*Gruplamaya önce <strong>en az komşuya sahip</strong> 1'lerden başla:*</p>\n</blockquote>\n<p><img src=\"static/img/ram/karna-kural2.gif\" alt=\"*Gruplamaya önce **en az komşuya sahip** 1&#x27;lerden başla.*\"></p>\n<p>Çok da değil aslında 2 tane mühim kuralımız varmış :)</p>\n<h3>Konumuza geri dönelim: “Tam Toplayıcı”</h3>\n<p>Karnaugh haritasını çizdiğimiz çıkışların denklemlerini yazalım:</p>\n<p><strong>SONUÇ</strong> = E.b1'.b2' + E’.b1'.b2 + E.b1.b2 + E’.b1.b2'\n<strong>ELDE</strong> = E.b2 + E.b1 + b1.b2</p>\n<p>Karnaugh’daki grupları yazdığımızda elde ettiğimiz sonuçlar böyle, fakat yine de tam istediğimiz sadelikte değil. Mantık ilminin matematiksel özelliklerini kullanarak buradan da sadeleştirmeler yapabiliriz.</p>\n<p><strong>SONUÇ</strong> = E.(b1'.b2' + b1.b2) + E’.(b1'.b2 + b1.b2')</p>\n<p>Dikkatli bakarsak 1. parantez içinin XNOR, (00 veya 11 koşulu)</p>\n<ol start=\"2\">\n<li>parantez içinin ise XOR (01 veya 10 koşulu) olduğunu görebiliriz.</li>\n</ol>\n<p>En sade haliyle **SONUÇ **çıkışımızın formülü şöyle olacaktır:</p>\n<p><strong>SONUÇ</strong> = E.(b1 ⊙ b2) + E’.(b1 ⊕ b2)\n<strong>SONUÇ</strong> = E.<strong>(b1 ⊕ b2)’</strong> + E’.(b1 ⊕ b2)</p>\n<blockquote>\n<p>A.B’ + A’.B = A⊕B</p>\n</blockquote>\n<p><strong>SONUÇ</strong> = E ⊕ b1 ⊕ b2\n(2 XOR)</p>\n<p>ELDE çıkışında ise E’leri paranteze alabiliriz:</p>\n<p><strong>ELDE</strong> = E.(b1⊕b2) + b1.b2\n<em>(2 VE, 1 XOR (yukarıdan), 1 VEYA)</em></p>\n<p>Devremizi gerçekleyelim:</p>\n<p><img src=\"static/img/ram/full-adder.gif\"></p>\n<h3>Karnaugh’yı da hallettik!</h3>\n<p>Temel derslerden en önemlisi olarak gördüğüm Karnaugh Haritalarını da bu yazıda bitirelim. <strong>0'dan RAM yapma hedefimize adım adım ilerliyoruz.</strong></p>\n<p>Bir sonraki yazımız olan <a href=\"0-dan-ram-4-kod-cozuculer\"><strong>0 → RAM | 4) Kod çözücüler</strong></a>'de görüşmek üzere.</p>","id":"ebb3cad0-2c8b-595c-99a5-acb67e541238","frontmatter":{"date":"Mart 04, 2020","description":"Mantık devreleri inşa etmek için mühim yöntemlerden birisi \"Karnaugh Haritaları\"","image":"static/img/ram/kapak-ram3.png","path":"/0-dan-ram-3-karnaugh-haritalari","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 3) Karnaugh Haritaları"}},{"excerpt":"Merhabalar! Bu derste mantıksal elektronik devreleri kurmak için olmazsa olmazımız olan Mantık Kapılarına göz atacağız. Mantığın kapısı mı olur? Mantık ilmi, bizim günlük hayatta karar verirken…","html":"<h2>Merhabalar!</h2>\n<p>Bu derste mantıksal elektronik devreleri kurmak için olmazsa olmazımız olan Mantık Kapılarına göz atacağız.</p>\n<h3>Mantığın kapısı mı olur?</h3>\n<p>Mantık ilmi, bizim günlük hayatta <strong>karar</strong> verirken beynimiz ile yaptığımız işlemleri matematiğe uyarlayan bir ilim. Bu ilim pek çok devasa ilim dalının temellerini oluşturuyor.</p>\n<p>Bugün bilgisayarda yaptığımız işlerin büyük çoğunluğu mantıksal çıkarımlar sayesinde olmakta.</p>\n<blockquote>\n<p>Mesela bu yazıyı beğenmek için beğen butonuna tıklamak. Bilgisayar sizin başka bir yere değil de özel olarak o butona tıkladığınızı nasıl anlar ki?</p>\n</blockquote>\n<p><strong>İşte burada mantık ilmi devreye girer.</strong> Kendi aklımızla bir butona tıklama işini nasıl tahayyül ediyorsak onu formülize edip bilgisayarın da aynı şeyi algılamasını sağlayabiliriz.</p>\n<p>Matematikte kullanılan mantıksal işaretler:</p>\n<ul>\n<li><strong>Λ</strong> | <strong>.</strong> | <strong>x</strong> = Ve</li>\n<li><strong>V</strong> | <strong>+</strong> = Veya</li>\n<li><strong>‘</strong> = Değil</li>\n<li><strong>⇒</strong> = İse</li>\n<li>⇔ = Çift yönlü ise (Ancak ve ancak)</li>\n</ul>\n<h3>Bir mantıksal işlem örneği yapalım:</h3>\n<p>Mesela benim aklım o butona basabilmek için 2 şart koşuyor:</p>\n<ol>\n<li>Ekrandaki imleç butonun üzerinde olmalı</li>\n<li>Elimdeki farenin sol tuşuna basmalıyım</li>\n</ol>\n<p>Bu işlemi matematiksel mantık ile yazmak istersek basitçe şöyle yazabiliriz:</p>\n<blockquote>\n<p>A: İmlecin buton üzerinde olması\nB: Farenin sol tuşuna basılması\nButonun tıklanmasına ise C diyelim.\nC, A ve B aynı anda sağlandığında doğru olur. Yani:</p>\n</blockquote>\n<p>C = A ve B</p>\n<p>veya matematiksel olarak ifade edersek.</p>\n<p>C = A Λ B <br>\nC = A.B</p>\n<p>Bu işlemi biraz daha açarsak, A işlemi aslında imlecin koordinatları ile butonun koordinatları arasında bir hesaptan ibaret. Öyleyse şöyle yazabiliriz:</p>\n<p><em>(buradaki b.y b.x gibi '.' kullanımı butonun y,x gibi özelliklerine erişme manasında kullanılmıştır.)</em></p>\n<p><strong>b:</strong> Buton <br>\n<strong>f:</strong> Fare <br>\n<strong>A:</strong> (f.x ≥ b.x) Λ (f.x &#x3C; (b.x + b.genişlik)) Λ (f.y ≥ b.y) Λ (f.y &#x3C; (b.y + b.yükseklik)) <br>\n<strong>B:</strong> f.SolTuşuTıklandıMı <br></p>\n<blockquote>\n<p>Bugün neredeyse bütün tıklanma kontrolleri ve basit çarpışma kontrolü A ve B formülünün 1 veya 0 sonuçlanmasına göre kontrol edilmekte.</p>\n</blockquote>\n<p>Koşullarımızı detaylandırdıysak artık <strong>C = A Λ B</strong> <em>(veya A.B, biz genelde yaygın olan nokta (.) gösterimini kullanacağız)</em> bize butonun tıklanıp tıklanmadığını veren mantıksal formül oldu.</p>\n<h3>Birkaç basit sözlü ifadeyi mantıksal ifadeye çevirelim:</h3>\n<p>“A butonuna basılır ve B butonuna basılmaz ise C koşulu doğrudur”:</p>\n<blockquote>\n<p>C = A.B’</p>\n</blockquote>\n<p>“T düğmesi veya J düğmesine basılırsa K kliması açılsın”:</p>\n<blockquote>\n<p>K = T+J</p>\n</blockquote>\n<p>“O ve P tuşları basılmıyor **veya **O ve P tuşları aynı anda basılıyor ise U koşulu doğrudur”:</p>\n<blockquote>\n<p>U = (O’.P’) + (O.P)</p>\n</blockquote>\n<p>U = (O+P)’ + (O.P) şeklinde de yazılabilir. — “O veya P basılıyor değilse”</p>\n<p>Gördüğünüz gibi mantıksal ifadeler oluşturmak gayet kolay :)</p>\n<p>Mantıksal ifadeler hakkında daha fazla bilgiyi ve bazı matematiksel kuramları <em>(De Morgan Kuralları gibi)</em> pek çok internet sayfasında ve YouTube kanallarında bulabilirsiniz.</p>\n<h3>Mantık güzel, peki “Kapıları” nedir?</h3>\n<p><strong>Mantık Kapıları</strong> yukarıda sadece kağıt üzerinde ifade ettiğimiz mantıksal ifadeleri gerçek hayatta donanımsal olarak gerçekleştirmemize olanak sağlayan elektronik devre elemanlarıdır.</p>\n<blockquote>\n<p>Örneğin bir kumandada iki butona birden basıldığında bir cihazın çalışması</p>\n</blockquote>\n<p>Elektronikte\n“VE kapısı” dediğimiz şey Mantıktaki <strong>Ve (Λ)</strong>’nin,\n“VEYA” kapısı da <strong>Veya (V)</strong>’nın karşılığıdır.</p>\n<p><img src=\"static/img/ram/mantik-kapilari-hepsi.gif\" alt=\"Mantık kapılarının tümü\"></p>\n<p>Çalışma şekilleri yukarıdaki gibi verilmiş kapıların matematiksel olarak da karşılıklarını bilmek isteriz. Çünkü her zaman ezbere iş yapamayız veya ilgilenen ifade git gide karmaşıklaşıp büyüyebilir.</p>\n<p>Bu yüzden <strong>Doğruluk Tablolarını</strong> kullanırız. Doğruluk tabloları bir <strong>elemanın</strong> veya bir <strong>ifadenin</strong> tüm giriş kombinasyonları için çıkışlarını gösterdiğimiz bir tablodan ibaret. Çok basit fakat çok yararlı.</p>\n<h3>Birkaç Doğruluk Tablosu örneği:</h3>\n<p>Mesela A ve B girişlerimiz olsun, bunlardan <strong>sadece bir tanesi</strong> 1 olduğu zaman doğru olan sonuçla Doğruluk Tablosunu çizelim:</p>\n<p><img src=\"static/img/ram/xor-tablo.png\" alt=\"XOR Doğruluk Tablosu\"></p>\n<p>Bu gördüğümüz tablo aslında <strong>Özel VEYA</strong>(XOR veya EXOR) kapısının doğruluk tablosudur.</p>\n<p><strong>Özel VEYA</strong> da örnek ile aynı şeyi gerçekleştirmekte. (yani Farklıysa 1, aynısya 0)</p>\n<p>Elinizdeki duruma göre istediğiniz girişlerde istediğiniz şekilde sonuçlar çıkaran doğruluk tabloları çizebilirsiniz.</p>\n<blockquote>\n<p>Matematiksel olarak ifade edilebilen her doğruluk tablosu gerçeğe dönüştürülebilir.\nBu yüzden bir olayı <strong>doğruluk tablosuna</strong> dökebilmek, onu elektronik ortama aktarabilmek demektir.</p>\n</blockquote>\n<p>Mesela yine A ve B girişlerimiz olsun, fakat şimdi sadece A da B de 1 olduğu zaman sonuç doğru olsun:</p>\n<p><img src=\"static/img/ram/and-tablo.png\" alt=\"AND Doğruluk Tablosu\"></p>\n<p>Bu gördüğümüz tablo da aslında <strong>VE</strong> (AND) kapısının doğruluk tablosudur.</p>\n<p><strong>VE</strong> kapısı sadece iki giriş de <strong>1</strong> olduğu, yani elektrik geldiği zaman 1 olur, sonuç olarak o da elektrik verir.</p>\n<p>Doğruluk Tabloları küçük boyutlarda işimize yarıyor, fakat örneğin elimizde 5 tane durum var ise ne yapacağız? <em>(Bunun için 32 satırlık bir doğruluk tablosu yapmamız gerekir :))</em></p>\n<p><strong>Böyle durumlarda Karnaugh Haritaları kullanırız.</strong> Karnaugh Haritaları doğruluk tablosunun iki boyutlu düzleme dökülmüş halidir. Yani durumlar tek bir sütun kaplamak yerine satır ve sütunlara dağıtılırlar.</p>\n<p><img src=\"static/img/ram/karna1.png\" alt=\"4 Duruma sahip basit bir karnaugh haritası. (Boş alanlar 0)\"><br>\n<em>4 Duruma sahip basit bir karnaugh haritası. (Boş alanlar 0)</em></p>\n<p>Karnaugh Haritalarının bir diğer bir avantajı ise işlemi sadeleştirmenin çok kolay yapılabilmesidir.</p>\n<p>Örneğin biz A ve B’nin sadece 11'de 1 ürettiğini gördüğümüz için kolayca bu tablo tek bir <strong>VE</strong> kapısıyla gerçeklenebilir diyebildik.</p>\n<p><strong>Fakat durum sayısı arttıkça birden fazla kapı gerekebilir. Ve bu durum işlem sadeleştirilmesi yapılmaz ise gereksiz kapı kullanımıyla sonuçlanabilir.</strong></p>\n<p><strong>Bu da daha fazla Masraf+ Boyut + Enerji harcaması demek.</strong></p>\n<blockquote>\n<p>İleride 1 bit veri saklama için kullanacağımız VE-VEYA Mandalı devresi Karnaugh Haritası ile yapılan sadeleştirme ile sadece 3 tane kapıdan oluşmakta.)</p>\n</blockquote>\n<p><strong>Mantık Kapıları</strong> ve <strong>Doğruluk Tablosu</strong>’nu hallettiğimize göre bu yazıyı bitirebiliriz.</p>\n<p>Bir sonraki yazımız olan <a href=\"0-dan-ram-3-karnaugh-haritalari\"><strong>0 → RAM | 3) Karnaugh Haritaları</strong></a>'nda görüşmek üzere!</p>","id":"a43c7591-3fab-5cce-bce4-23d319b757e7","frontmatter":{"date":"Mart 03, 2020","description":"İleride sıkça kullanacağımız mantık kapılarına bir el atalım.","image":"static/img/ram/kapak-ram2.png","path":"/0-dan-ram-2-mantik-kapilari","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 2) Mantık Kapıları"}},{"excerpt":"Merhabalar! (0 → RAM)* *serisinde sizlerle beraber sıfırdan kendi RAM’imizi tasarlayacağız. Bu yazıda tasarıma hemen geçmesek de genel bir bilgi edinmek için okumanız faydalı olacaktır. Başarılar! Ram…","html":"<h2>Merhabalar!</h2>\n<p><strong>(0 → RAM)*</strong> *serisinde sizlerle beraber <strong>sıfırdan</strong> kendi <strong>RAM</strong>’imizi tasarlayacağız. Bu yazıda tasarıma hemen geçmesek de genel bir bilgi edinmek için okumanız faydalı olacaktır. Başarılar!</p>\n<h3>Ram Nedir?</h3>\n<p><strong>R</strong>andom <strong>A</strong>ccess <strong>M</strong>emory, yani Rastgele Erişimli Bellek.</p>\n<p>“Rastgele Erişimli” denilmesinin sebebi bellekteki hafıza bölümlerine “kaotik” veya “neresi rast gelirse” şeklinde erişmemiz değil.</p>\n<p>İstediğimiz (yani herhangi bir, yani rastgele), hafıza bölümüne <strong>tek seferde</strong> erişebildiğimiz için böyle tesmiye edilmiş.</p>\n<p><img src=\"./rastgele-sirali.gif\" alt=\"Bellekteki bir adrese erişim türü farkları [ Rastgele | Sıralı ]\"><em>Bellekteki bir adrese erişim türü farkları [ Rastgele | Sıralı ]</em></p>\n<h3>Ram Ne İşe Yarar?</h3>\n<p>İşlemcimizin en çok konuştuğu donanımlardan biri olan RAM, işlemciye lazım olacak <strong>veriler ve komutları</strong> geçici olarak saklayan ve istenildiğinde de tekrar okumamızı sağlayan bir elektronik devredir.</p>\n<p>Mesela bilgisayarınızda bir program çalıştırdığınız zaman bu program <strong>kalıcı ve yavaş</strong> bellekten okunarak (yani sabit diskinizden) <strong>geçici ve hızlı</strong> (yani RAM) belleğe aktarılır. Daha sonra İşlemci bu programın RAM’de tutulan komutlarını tek tek okuyup çalıştırmaya başlar.</p>\n<blockquote>\n<p>Mesela a ile b’yi topla, RAM’de diğer bir adrese şu veriyi yaz, şu adresteki veriyi 1 arttır gibi komutlar…</p>\n</blockquote>\n<p>İşlemcinin programları sabit diskinizden okuyup çalıştırmama sebebi okuma-yazma hızının çok düşük olmasıdır.</p>\n<blockquote>\n<p>Örneğin ortalama bir <strong>RAM</strong> 15–20GB/s okuma-yazma hızına sahipken, ortalama bir <strong>SSD</strong> 0.4–0.5GB/s hızlarında. ortalama bir <strong>HDD</strong> ise 0.02–0.03GB/s.</p>\n</blockquote>\n<p>Eğer sabit diskten çalıştırsa idi işlemci çok hızlı olmasına rağmen sabit diski sürekli beklemek zorunda kalacaktı, böylece zaman kaybı had safhada olacaktı.</p>\n<h3>“RAM’i anladım, fakat bir veri elektrik ile nasıl saklanabilir ki? Sabit disk üzerindeki kabartılar ile veriyi kolayca saklayabiliyor. Elektrik nasıl saklanır?”</h3>\n<p>Elektrik tek başına saklanabilen bir şey değil evet, ama basit devreler yardımıyla elektriği saklayabiliyoruz.</p>\n<p>Mesela “veri saklama” dediğimiz işini gerçekleştirebilen en basit devrelerden biri <strong>AND-OR Latche</strong> yani <strong>Ve-Veya Mandalı</strong>’dır.</p>\n<p>Bu ismin verilme sebebi sadece 1 VE ve 1 VEYA kapısıyla oluşturulabilmesidir. <em>(bir tane de DEĞİL kapısı var aşağıda tabiki :))</em></p>\n<p><img src=\"./andor-latche.gif\" alt=\"1 bit veri saklayabilen AND-OR-Latche çalışma şekli\"><em>1 bit veri saklayabilen AND-OR-Latche çalışma şekli</em></p>\n<p>Bu devreyi Mantık Devreleri (veya Elektrik Devreleri) tasarlama programları aracılığıyla kendiniz de tasarlayıp simüle edebilirsiniz. Ayrıca ilerideki tasarımlarımızı da kendi bilgisayarınızda gerçeklemek için bu programlara ihtiyacınız olacak.</p>\n<p>Kullanabileceğiniz zordan kolaya sıralı bazı bedava programlar:</p>\n<ul>\n<li><strong>Logisim</strong> (<a href=\"https://sourceforge.net/projects/circuit/\">https://sourceforge.net/projects/circuit/</a>)\n*(Kapsamlılık: 15, Zorluk: 2) <strong><em>kullandığım</em></strong></li>\n<li><strong>Logic Circuit</strong> (<a href=\"https://logiccircuit.org/\">https://logiccircuit.org/</a>)\n<em>(Kapsamlılık: 10, Zorluk: 4)</em></li>\n<li><strong>Logic Circuit Designer</strong> (<a href=\"https://sourceforge.net/projects/logiccircuitd/\">https://sourceforge.net/projects/logiccircuitd/</a>)\n<em>(Kapsamlılık: 7, Zorluk: 2)</em></li>\n<li><strong>Multimedia Logic</strong> (<a href=\"https://sourceforge.net/projects/multimedialogic/\">https://sourceforge.net/projects/multimedialogic/</a>)\n<em>(Kapsamlılık: 4, Zorluk: 1)</em></li>\n</ul>\n<p>Bu devreyi nasıl oluşturacağımız, kapıların nasıl çalıştığı, doğruluk tabloları, karnaugh haritaları gibi teknik meselelere artık başlayabiliriz sanırım.</p>\n<p>Şimdilik bu kadar :)</p>\n<p>Bir sonraki yazımız olan <strong><a href=\"0-dan-ram-2-mantik-kapilari\">0 → RAM | 2) Mantık Kapıları</a></strong>'ında görüşmek üzere!</p>","id":"1e043096-c121-5391-8ff9-e820ff9a0aa2","frontmatter":{"date":"Mart 02, 2020","description":"Sıfırdan RAM tasarladığımız bir seri.","image":"static/img/ram/kapak-ram1.png","path":"/0-dan-ram-1-ram-nedir","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 1) RAM Nedir?"}}],"Genel":[{"excerpt":"Bismillâh her hayrın başıdır. Biz dahi başta ona başlarız. Bil ey nefsim! Şu mübârek kelime İslâm nişanı olduğu gibi, bütün mevcudâtın lisân-ı haliyle vird-i zebânıdır. ... İşte, ey mağrur nefsim, sen…","html":"<p><strong>Bismillâh</strong> her hayrın başıdır. Biz dahi başta ona başlarız.</p>\n<p>Bil ey nefsim!</p>\n<p>Şu mübârek kelime <strong>İslâm nişanı</strong> olduğu gibi, bütün mevcudâtın lisân-ı haliyle vird-i zebânıdır.</p>\n<p>...</p>\n<p>İşte, ey mağrur nefsim, sen o seyyahsın. Şu dünya ise bir çöldür. Aczin ve fakrın hadsizdir. Düşmanın, hâcâtın nihayetsizdir. Mâdem öyledir, şu sahrânın Mâlik-i Ebedîsi ve Hâkim-i Ezelîsinin ismini al. Tâ bütün kâinatın dilenciliğinden ve her hâdisâtın karşısında titremeden kurtulasın.</p>\n<p>...</p>\n<p>Ey nefis! Böyle ebleh olmamak istersen; Allah nâmına ver, Allah nâmına al, Allah nâmına başla, Allah nâmına işle, vesselâm...</p>\n<p>| Birinci Söz, Sözler, Risale-i Nur</p>","id":"3765eac9-1f3a-508c-aa3c-bb01b3ab82c8","frontmatter":{"date":"Mart 01, 2020","description":"Bismillah her hayrın başıdır.","image":"https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/fa6c3540-92bb-4f6c-9fa7-7c78f7c4eebf/d40jn8g-6211b31e-8326-4a98-9aa9-f9b83e657a32.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcL2ZhNmMzNTQwLTkyYmItNGY2Yy05ZmE3LTdjNzhmN2M0ZWViZlwvZDQwam44Zy02MjExYjMxZS04MzI2LTRhOTgtOWFhOS1mOWI4M2U2NTdhMzIuanBnIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.Wpgx9vPJ2tUWkBVyZ0IIUseByEqeqFfg1yLMGkuiMXM","path":"/bismillah","tags":["Genel"],"templateKey":"blog-post","title":"Bismillah"}}]},"post":[{"excerpt":"Merhabalar! Bu yazımızda RAM’imizi tasarlamayı bitiriyoruz. Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efenim. Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efendim. RAM…","html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizi tasarlamayı bitiriyoruz.</p>\n<p><img src=\"static/img/ram/buzz-eriste.jpeg\" alt=\"Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efenim.\"> <br><em>Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efendim.</em></p>\n<h2>RAM’imizin içini adım adım tasarlayalım:</h2>\n<ol>\n<li>Adres girişlerinden aldığımız sayıyı 4. Yazıda ele aldığımız <a href=\"0-dan-ram-4-kod-cozuculer\">Kod Çözücüleri</a> kullanarak iki boyutlu <a href=\"0-dan-ram-5-ram-hucresi\">Ram Hücreleri</a> matrisi hazırlayalım.</li>\n<li>Bu matrisin içine hücrelerimizi yerleştirip hücrenin “<strong>EN</strong>”<em>(aktif etme)</em> ucunu iki kod çözücüden gelen seçim uçlarına “<strong>VE</strong>” kapısı ile bağlayacağız. *(Mesela <strong>0. satır</strong> ve <strong>4. sütun</strong> seçim uçları <strong>aktif ise</strong> (0, 4)'teki hücreyi aktif et)*</li>\n<li>RAM’e erişimin okumak için mi yazmak için mi olduğunu öğrendiğimiz <strong>R/W’</strong> girişini bütün <strong>hücrelerin R/W</strong>’ girişlerine <strong>teker teker</strong> bağlayacağız.</li>\n<li>Seçtiğimiz RAM hücresinden veriyi okuyacağımız veya yazacağımız pin olan <strong>I/O</strong> (Giriş/Çıkış) pinini de bütün <strong>hücrelerin I/O</strong> girişine bağlayacağız.</li>\n<li>Chip Select girişini ise direkt olarak bütün girişlerle VE kapılayabiliriz ama bu biraz uzun ve gereksiz bir uğraş olur gibi.\nOnun yerine; eğer gerçekten yapacak olsaydık, decoder gibi komponentlerimizin VCC ve GND uçları olacağından sadece VCC uçlarını VE kapılayabilirdik. <em>(yani çipe elektriği verip vermeme şeklinde bir anahtarlama olabilir.)</em>\n<em>(O yüzden CS pini görselde bir yere bağlı değil :))</em></li>\n</ol>\n<p><img src=\"static/img/ram/ram-full.png\" alt=\"4000x4000 çözünürlüğe sahip RAMcik içi.\">\n<br><em>4000x4000 çözünürlüğe sahip RAMcik içi.</em></p>\n<p>Bütün bunları sırasıyla yaptığımızda karşımızda RAM’imiz için 8 tanesini yan yana getireceğimiz 256 boyutunda 1 bit saklayabilen <strong>“RAMcik”</strong>leri elde ederiz :).</p>\n<p>(😲)</p>\n<div style=\"width: 100%; height: 0px; position: relative; padding-bottom: 100.000%;\"><iframe src=\"https://streamable.com/s/xwc8s/nrcvlh\" frameborder=\"0\" width=\"100%\" height=\"100%\" allowfullscreen style=\"width: 100%; height: 100%; position: absolute;\"></iframe></div>\n<p><a href=\"https://streamable.com/xwc8s\">> HD Video</a></p>\n<p>Şema olarak RAM’imizden tek farkı veri çıkışında sadece 1 tane pin olması. <em>(Çünkü 256 farklı adres için sadece 1 bit saklayan hücrelerden oluşuyor)</em></p>\n<p>Bu 256 farklı adreste 1 bit saklayan “RAMcik”lerimizden 8 tane yan yana getirip, veri çıkışlarını da yüksek önemli bitten düşük önemli bite göre bağlayıp CS ve R’/W uçlarını da RAM’in CS ve R’/W uçlarına bağlar isek, 256x8'lik bir RAM yapmış oluruz.</p>\n<p><img src=\"static/img/ram/ram-son-hal.gif\" alt=\"Ve RAM!\"></p>\n<h2>Ve RAM!</h2>\n<p>Tebrikler!</p>\n<p>6 yazılık bu bloğu okuyup anlayarak kendi RAM’inizi sıfırdan tasarlamayı öğrendiniz. <em>(her yiğidin harcı değil )</em></p>\n<p><img src=\"static/img/ram/congrats.jpeg\" alt=\"Tebrikler!\"><br><em>Tebrikler!</em></p>\n<blockquote>\n<p>Eğer babanızdan kalma fabrika zincirleriniz varsa veya milyoner bir iş adamıysanız bu bilgiler üzerine biraz daha koyarak (256 Byte yetmez şimdi tabi, bunu nano seviyede küçültüp 8GB yi sığdırmanız lazım oraya :)) gerçek ve elle tutulur bir RAM yapıp ülkeye güzel bir ihracat geliri getirebilirsiniz :)</p>\n</blockquote>\n<p>Veya kişisel çaplı projelerde kullanılmak üzere (mesela bir arduino projesi) modül olarak takılabilir bir RAM yapıp insanlara sunabilirsiniz. <em>(veya satabilirsiniz :))</em></p>\n<blockquote>\n<p>Tabi bu işin de kendince standartları var, bizim yaptığımız RAM tamamen kendi standartlarımız ve tercihlerimize dayalı oldu.</p>\n</blockquote>\n<h2>Bundan Sonra</h2>\n<p>Daha da derinlere inip bu işin ehli olmak isterseniz inceleyebileceğiniz birkaç wikipedia linki ekleyelim:</p>\n<p>RAM çeşitleri olarak <a href=\"https://www.wikiwand.com/en/Static_random-access_memory\">SRAM</a>, <a href=\"https://www.wikiwand.com/en/Dynamic_random-access_memory\">DRAM</a>.\n<em>(RAM var RAM var, hepsi aynı değil tabi)</em></p>\n<p>İşlemci ile RAM’in arasındaki iletişim standartları olarak ise<a href=\"https://www.wikiwand.com/en/Double_data_rate\"> SDR, DDR, QDR</a> gibi konulara bakabilirsiniz.\n<em>(Gözünüz korkmasın, bunlar sadece belirli standartlar, çok farklı ve gelişmiş şeyler değil, buraya kadar geldiyseniz bunları da kolayca anlayabilirsiniz.)</em></p>\n<p>Günleriniz ve ömrünüz bol bereketli ve hayırlı olsun.\n<br> <strong>İyi günler.</strong></p>","id":"cce30859-a23d-5d5c-bee0-6adb5f5ab6c3","frontmatter":{"date":"Mart 07, 2020","description":"Ve RAM'imizin son hali :)","image":"static/img/ram/kapak-ram6.png","path":"/0-dan-ram-6-ram-hucresi","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 6) Ve RAM!"}},{"excerpt":"Merhabalar! Bu yazımızda RAM’imizin iç devresini tasarlamaya başlayacağız. Atacağım devre dosyaları Logisim programından olacak. Tamamen sıfırdan kendi RAM’inizi inşa edip, simüle edip test…","html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizin iç devresini tasarlamaya başlayacağız. Atacağım devre dosyaları <a href=\"https://sourceforge.net/projects/circuit/\"><strong>Logisim</strong></a> programından olacak. Tamamen sıfırdan kendi RAM’inizi inşa edip, simüle edip test edebileceksiniz :)</p>\n<h2>RAM’imiz nasıl bir şey olacak?</h2>\n<p>RAM’imizin iç devresini tasarlamadan önce içi hazır bir eleman olarak düşünüp sadece giriş ve çıkışlarını tasarlayalım. <strong>Yani genel hatlarını belli edelim.</strong></p>\n<p>RAM’imiz <strong>2⁸x8</strong> boyutlarında olacak. Buradaki ilk değer RAM’in içindeki <strong>hücre</strong> sayısıdır. Yani 2⁸ tane <strong>çekmeceden</strong> oluşan bir dolap gibi düşünülebilir.</p>\n<p>İkinci değer (8) ise her çekmecenin içinde saklanan bit sayısıdır.</p>\n<p>Yani 2⁸=256 tane hücremiz var, her hücrede de 8 bit saklıyoruz.</p>\n<blockquote>\n<p>Dolayısıyla RAM’imiz <strong>2048</strong> adet <strong>0</strong> veya <strong>1</strong> saklıyor\n<strong>8 bit = 1 byte</strong> olduğundan <strong>256 Byte</strong>’lık bir RAM’imiz olacak.</p>\n</blockquote>\n<p>Eğer 1GB’lık bir RAM yapmak isteseydik:</p>\n<p><strong>1GB için 2³⁰x8</strong><br>\n<strong>2GB için 2³¹x8</strong><br>\n<strong>4GB için 2³²x8</strong>\nbir RAM tasarlayacaktık.</p>\n<p>32 bit işlemcilerin olduğu sistemlere 4GB’dan fazla RAM <strong>takılamamasının</strong> sebebi en fazla <strong>2 üzeri 32'ye</strong> kadar adres tutabilmesidir. Yani 2³²’den ekstra 1 tanecik fazla da olsa hücreyi adresleyemez, veriyi saklayamaz, tanımlayamaz, saklaması için 33. yeni bir bite ihtiyacı var.</p>\n<p>64 bit sistemler ise 2⁶⁴ yani <strong>“18 446 744 073 709 551 616 Byte”</strong> hafızaya sahip olacak kadar adresleme yapabilir, bu da yaklaşık <strong>“17 179 869 184 GB”</strong> yapıyor :) <em>(4GB’ye göre gerçekten yüksek bir rakam)</em></p>\n<blockquote>\n<p>Yani 64 bit işlemciye sahip bir bilgisayarınız varsa 17 Milyar GB RAM’e kadar yükseltme yapabilirsiniz (tabi gerçek hayatta adres tutmak için 64 bitin hepsi ayrılmaz :))</p>\n</blockquote>\n<h3>RAM Çipimizin Genel Tasarımı</h3>\n<p><img src=\"static/img/ram/ram-chip.png\" alt=\"RAM Çipimizin Genel Tasarımı.\"></p>\n<p><em>RAM Çipimizin Genel Tasarımı.</em></p>\n<p><strong>Y:</strong> Yüksek Değerlikli Bit (<strong>2⁷</strong>)<br>\n<strong>D:</strong> Düşük Değerlikli Bit (<strong>2⁰</strong>)<br>\n<strong>CS (Chip Select):</strong> RAM çipimizi aktif eden giriş.<br>\n<strong>R’/W:</strong> Okuma yapmak için <strong>0 (R’)</strong> Yazma yapmak için <strong>1 (W)</strong> değeri verilmesi gereken girişimiz.</p>\n<p>--</p>\n<p>Çipimiz tamam, peki işlemci ile veri alışverişini nasıl sağlayacak? Çıkışları direk işlemciye mi bağlayacağız? Eğer öyle ise her yaptığımız eleman için işlemcide ayrı ayrı çıkışların mı olması gerek?</p>\n<h3>Veri Aktarım Yöntemi</h3>\n<p>Normal şartlarda iki şekilde bir çipi başka bir çip ile haberleştirebilirsiniz:</p>\n<p><strong>1.</strong> Direkt olarak birinin <strong>çıkışlarını</strong> diğerinin <strong>girişlerine</strong> bağlarsınız</p>\n<p><strong>2.</strong> İki veya daha fazla çipi ortak bir tane veri yoluna bağlayıp, <strong>Çip Seçim</strong> girişleri ile sadece konuşturmak istediğiniz çipleri aktif ederek veri aktarımını sağlarsınız.</p>\n<p><em>(Örneğin SSD’den veri okuyacağım, o zaman SSD’yi aktif edip diğerlerini pasif halde tutarım. Veya RAM’den veri okumak istiyorum, diğerlerini pasif hale getirip bu sefer de sadece RAM’i aktif ederim)</em></p>\n<p><img src=\"static/img/ram/common-data-bus.gif\" alt=\"Ortak veri yolu kullanan çiplerin Chip Select girişi kullanılarak veri yoluna bağlanması.\">\n<br><em>Ortak veri yolu kullanan çiplerin Chip Select girişi kullanılarak veri yoluna bağlanması.</em></p>\n<h2>Gelelim artık RAM Hücresine!</h2>\n<p>Güzel bir söz var:</p>\n<blockquote>\n<p><strong>\"Baharı icad etmeyen, bir elmayı icad edemez. Zira o elma, o tezgâhta dokunuyor. Bir elmayı icad eden, bir baharı icad edebilir…\"</strong></p>\n</blockquote>\n<p>Bunun RAM ile alakası ise;</p>\n<blockquote>\n<p>Milyarlarca biti saklayabilmek için önce 1 biti saklayabilmek gerek,\n1 biti saklayamayan milyarları saklayamaz.\nMilyarları saklayabilen 1 biti saklayabilendir.</p>\n</blockquote>\n<p>Yani önce <strong>tek bir biti saklayabilen</strong> bir <strong>“RAM Hücresi”</strong> yapıp sonra bunu istediğimiz sayıda kopyalarak istediğimiz boyutta RAM elde edeceğiz.</p>\n<p><img src=\"static/img/ram/ram-cell.gif\" alt=\"Ramimize 1 bitlik veri saklama işini gerçekleştirecek temel RAM Hücresi. İç planı ve dışarıya soyutlanmış halleri.\">\n<br> <em>Ramimize 1 bitlik veri saklama işini gerçekleştirecek temel RAM Hücresi. İç planı ve dışarıya soyutlanmış halleri.</em></p>\n<p>Hücremizin içinde kullandığımız devrede ilginç bir eleman görebilirsiniz. <em>(D Q ve CLK yazan)</em></p>\n<p>Bu eleman ilk derste gösterdiğim <strong>AND-OR-LATCHE</strong> yani Ve-Veya Mandalı’nın birazcık daha değişik hali.</p>\n<blockquote>\n<p>Ve-Veya mandalı <strong>SET</strong> kısmına 1 verilince verimiz <strong>1</strong>\n<strong>Reset</strong> kısmına 1 verilince verimiz <strong>0</strong> oluyordu.</p>\n</blockquote>\n<p>Biz ise Set-Reset mantığı yerine,<strong>hangi veriyi verirsek onu saklayan</strong> bir mandal <em>( veya daha gelişmişi: Flip/Flop )</em> istiyoruz.</p>\n<p><strong>D-Tipi</strong> Flip Floplar da bu görevi gerçekleştiriyor.</p>\n<p>Merak etmeyin, baştaki mandalımıza <strong>2 VE</strong> ve <strong>1 Değil</strong> kapısı ekleyerek D-Tipi F/F elde edebiliriz.</p>\n<p>Logisim programında tasarladığım çalışan bir D-Tipi F/F’nin görüntüsü şu şekilde: <em>(yani RAM hücremizin içindeki D Q ve CLK yazan devre elemanının içi)</em></p>\n<p><img src=\"static/img/ram/logisim-d-ff.png\" alt=\"D-Tipi F/F iç devresi\"> <br>\n<a href=\"https://shorturl.at/kyDOY\">Logisim programında çalışan bir D tipi F/F devre dosyası</a></p>\n<blockquote>\n<p>Kırmızı çizgi ile ayırdığım kısmın sağında kalan parçalar ilk dersimizdeki <strong>Ve-Veya</strong> mandalı. Ek olarak sadece soldaki <strong>2 tane VE, 1 tane Değil</strong> kapılarını ekledik.</p>\n</blockquote>\n<p><strong>Bu bağlantıları neye göre yapacağımızı</strong> ve hangi kapıları ekleyeceğimizi D-Tipi F/F’lerin doğruluk tablosunu çizerek kendiniz de elde edebilirsiniz. <em>(ipucu olarak Data ve CLK girişlerine karşılık Set ve Reset çıkışlarının durumları tablosunu kullanarak devreyi elde edebilirsiniz.)</em></p>\n<h2>RAM Hücremiz tamam. Hadi şimdi bununla bir RAM yapalım!</h2>\n<p>Bu yazı hem biraz uzun oldu, hem de RAM’in direkt olarak iç dizaynını ayrı bir yazıda ele almak amacıyla <em>(tüm her şey tek bir yazıda toplanıp çorba gibi olmasın, ayrı ayrı düzenli olsun)</em> en iyisi bir sonraki yazıya bırakalım :)</p>\n<p>Serimizin son yazısı olacağını tahmin ettiğim <a href=\"0-dan-ram-6-ve-ram\">0 → RAM | 6) Ve RAM!</a> Yazımızda görüşmek üzere.</p>\n<p>Esenlikler ve mutluluklar içinde kalınız.<br>\nSelamün aleyküm.</p>","id":"b18792b7-1dc2-5bcc-8e8f-be868cc1ed80","frontmatter":{"date":"Mart 06, 2020","description":"Temel RAM bileşenlerimizin sonuncusu \"Kod Çözücüler\"","image":"static/img/ram/kapak-ram5.png","path":"/0-dan-ram-5-ram-hucresi","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 5) RAM Hücresi"}},{"excerpt":"Merhabalar! Bu yazımızda RAM’imizin içindeki belirli adreslere erişmek için devremizde kullanacağımız Kod Çözücüleri ve Kodlayıcıları ele alacağız. Kod Çözücüler ne işe yarar? Bir Kod Çözücü kısaca…","html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizin içindeki belirli adreslere erişmek için devremizde kullanacağımız <strong>Kod Çözücüleri</strong> ve <strong>Kodlayıcıları</strong> ele alacağız.</p>\n<h2>Kod Çözücüler ne işe yarar?</h2>\n<p>Bir Kod Çözücü kısaca: <strong>seçim elemanıdır.</strong></p>\n<p>Girişlerine ikilik tabanda verilen girdiye göre sadece bir çıkışını aktif eder. Örneğin <strong>2 girişli</strong> ve <strong>4 çıkışlı</strong> (2x4) bir Kod Çözücü aşağıdaki gibi çalışır:</p>\n<blockquote>\n<p>00 -> <strong>0</strong></p>\n<p>01 -> <strong>1</strong></p>\n<p>10 -> <strong>2</strong></p>\n<p>11 -> <strong>3</strong></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*XHlRexbJWrW9BobgAUxDtQ.gif\" alt=\"2 Giriş, 4 Çıkışlı bir kod çözücünün çalışma şekli.\"></p>\n<p><em>2 Giriş, 4 Çıkışlı bir kod çözücünün çalışma şekli.</em></p>\n<p>Gördüğünüz gibi burada decoderin(kod çözücünün) iç devre tasarımı yok, bize sadece giriş ve çıkış uçları olan bir devre elemanı olarak verilmiş.</p>\n<p>Bu olaya <strong>abstraction</strong> yani <strong>soyutlama</strong> denir.</p>\n<p>Çoğu zaman yaptığımız ve bir işlevi gerçekleştirebilen küçük devreleri her seferinde tekrardan çizmeyiz. Bir kere çizdikten sonra onları bir eleman haline getirip sonra çoğaltarak istediğimiz kadar kullanırız. <em>(Bu düstur yazılımda da sıkça kullanılmaktadır)</em></p>\n<p>Fakat biz yine de kendi decoderimizi de yapmayı öğrenebilmek adına içine bir göz atalım :)</p>\n<p><em>Aslında gayet basit bir iç devresi var.</em></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*N3XCDp5dOmWpUfCdqYm0Hg.gif\" alt=\"2x4 Kod Çözücünün içi.\"><em>2x4 Kod Çözücünün içi.</em></p>\n<p>Siz de kolayca çıkışlarımızın mantıksal durumlarını yazarak devreyi rahatlıkla bulabilirdiniz. Nitekim biz de öyle yaptık:</p>\n<blockquote>\n<p>Y0= X1’.X0’ (00)</p>\n<p>Y1= X1’.X0 (01)</p>\n<p>Y2= X1.X0’ (10)</p>\n<p>Y3= X1.X0 (11)</p>\n</blockquote>\n<h3>“İyi güzel de, bu RAM yaparken ne işimize yarayacak?”</h3>\n<p>Eğer yazılım ile uğraşıyorsanız, özellikle C/C++ gibi adreslemelerin <em>(pointer)</em> bolca kullanıldığı dillerde tanımladığınız <strong>değişkenlerin</strong> bir <strong>adresi</strong> olduğunu fark etmişsinizdir.</p>\n<p>Bu adres genelde <strong>0x123456</strong> şeklinde onaltılık tabanda gösterilen bir sayı olur ve değişkeninizdeki <strong>verinin</strong> RAMinizde 0x123456 nolu bellek hücresinde tutulduğunu belirtir.</p>\n<h3>Mesela:</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*ZUdJocmCbepWUyJnPSk-5w.png\" alt=\"a isminde bir değişkenin RAM’deki bir hücrede saklanması.\"></p>\n<p><em>a isminde bir değişkenin RAM’deki bir hücrede saklanması.</em></p>\n<h3>İşte tam burada kod çözücüler devreye giriyor.</h3>\n<p>Bilgisayarda tüm işlemlerimiz İkilik (Binary) sistemde, yani 0 veya 1.</p>\n<p>0x100002 nolu hücreye erişebilmek için <strong>örneğin 4GB</strong>’lik bir RAM’de <strong>4,294,967,296</strong> tane hücreden <strong>sadece 1 tanesini</strong> seçip okumamız/yazmamız gerek ve bunu ikilik sistemde çalışan işlemcimizden aldığımız bitler ile yapabilmeliyiz.</p>\n<p>Kod Çözücüler ise seçim elemanlarıydı ve tam da aradığımız gibi; girişlerine ikilik sistemden bir sayı alıp, çıkışlarından sadece o sayıya karşılık gelen çıkışı aktif hale getiriyordu.</p>\n<p>Bu şekilde eğer bir Kod çözücüye <strong>2³² = 4,294,967,296</strong> hesabıyla <strong>32 giriş</strong> ve <strong>4,294,967,296</strong> farklı çıkış verirsek tüm hücrelere rahatlıkla erişebiliriz değil mi?</p>\n<h3>Aslında pek de sayılmaz :)</h3>\n<p>4,294,967,296 tane kabloyu teker teker bir hücreye bağlamak hem kablo, hem alan hem de işlem israfı olacaktır. Bu yüzden tek boyutlu olarak düşündüğümüz hücreleri adresleme işlemini iki boyutlu düşünmeliyiz. Yani 1 boyutlu bir dizi değil de, 2 boyutlu bir Matris olarak hücrelerimizi tutmalıyız.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*-KvuViSro2avKO3wtKrXww.gif\" alt=\"2 boyutlu matris kullanarak daha az kablo kullanımını sağlamak.\"><em>2 boyutlu matris kullanarak daha az kablo kullanımını sağlamak.</em></p>\n<p>4GB’lik bir RAM için ise 2³² şeklinde tek bir decoder yerine, 2⁸’lik 4 tane decoder kullanılabilir. Böylece kablo sayısı 4,294,967,296'dan 128'e düşüyor. Bu da bize <strong>33 milyon kat</strong> daha az kablo kullanımı ile muazzam bir tasarruf sağlıyor.</p>\n<h2>Kod çözücüler de tamam!</h2>\n<p>Artık RAM yapabilmek için temel bileşenlerin çoğunun çalışma şeklini biliyoruz.</p>\n<p>Şimdi geriye bu bileşenleri kullanarak bir RAM tasarlamak kaldı.</p>\n<p>Bir sonraki yazımız olan <strong><a href=\"0-dan-ram-5-ram-hucresi\">0 → RAM | 5) RAM Hücresi</a></strong>'inde görüşmek üzere!</p>","id":"46b74bd1-d671-5a63-8562-d70a94ae6ec4","frontmatter":{"date":"Mart 05, 2020","description":"Temel RAM bileşenlerimizin sonuncusu \"Kod Çözücüler\"","image":"static/img/ram/kapak-ram4.png","path":"/0-dan-ram-4-kod-cozuculer","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 4) Kod Çözücüler"}},{"excerpt":"Merhabalar! Önceki derste Mantık Kapılarına ve Doğruluk Tablolarına giriş yapmıştık. Doğruluk Tabloları güzeldi fakat bir eksiği vardı ki; kapı sayısı arttıkça Doğruluk Tablolarının çekilemez…","html":"<h2>Merhabalar!</h2>\n<p>Önceki derste <strong>Mantık Kapıları</strong>na ve <strong>Doğruluk Tabloları</strong>na giriş yapmıştık. Doğruluk Tabloları güzeldi fakat bir eksiği vardı ki; kapı sayısı arttıkça <strong>Doğruluk Tabloları</strong>nın çekilemez uzunluklara ulaşması ve sadeleştirme işlemlerinin biraz daha zor görülmesiydi.</p>\n<p>İşte bu sıkıntıları çekmemek için Maurice Karnaugh ve Edward Veitch’in güzel bir çalışması olan Karnaugh (Karnaugh-Veitch) Haritalarını kullanacağız.</p>\n<h2>Karnaugh Haritaları (Karnaugh-Veitch Maps)</h2>\n<p>Karnaugh Haritaları basitçe doğruluk tablosunun aşağıya doğru uzayan hali yerine <strong>iki boyutlu bir tablo</strong> haline getirilmesinden ibaret. <strong>Fakat bize sağladığı kolaylıklar çok fazla. :)</strong></p>\n<h3>Bir örnek yapalım:</h3>\n<p>Örneğimiz bir toplayıcı devresi olsun. Devremizde <strong>Bit-1</strong>, <strong>Bit-2</strong> butonları (girişleri) ve <strong>SONUÇ</strong> ve <strong>ELDE</strong> çıkışları (buralara LED bağlayabiliriz) olsun.</p>\n<p>Gireceğimiz iki biti toplayan ve eğer <strong>elde <em>(carry)</em></strong> değeri elde edersek <strong>ELDE</strong> çıkışını 1 yapan <em>(amma çok elde kelimesi geçti… :))</em>, toplama sounucunu da <strong>SONUÇ</strong> çıkışına veren bir devre yapalım. Bu devrenin doğruluk tablosunu çizersek şöyle bir sonuç elde ederiz:</p>\n<p><img src=\"static/img/ram/half-adder-tablosu.png\" alt=\"Yarım Toplayıcı(Half-Adder) Doğruluk Tablosu\"><em>Yarım Toplayıcı(Half-Adder) Doğruluk Tablosu</em></p>\n<p><strong>“Sonuç”</strong> çıkışı görebileceğimiz üzere bir <strong>Özel VEYA</strong> (XOR) kapısı ile gerçeklenebilir, çünkü sadece tet bir bit <strong>1</strong> olduğu zaman çıkış <strong>1</strong>.</p>\n<blockquote>\n<p>XOR: ⊕</p>\n<p>XNOR: ⊙</p>\n</blockquote>\n<p><strong>“Elde”</strong> çıkışımız ise sadece iki bit de 1 olduğu zaman 1 oluyor. O halde Elde çıkışı bir <strong>VE</strong> kapısı ile gerçeklenebilir. Bu durumda devremizin Sonuç çıkışının mantık kapılarıyla formülünü çıkarmak istersek:</p>\n<blockquote>\n<p><strong>Sonuç</strong> = <strong>b1 ⊕ b2</strong></p>\n<p><strong>Elde</strong> = <strong>b1 . b2</strong></p>\n</blockquote>\n<p>Tebrikler, bir <strong>Yarım Toplayıcı</strong> yaptınız :)</p>\n<h2>İyi de neden “Yarım” oldu ki?</h2>\n<p><img src=\"static/img/ram/half-adder.gif\" alt=\"Yarım Toplayıcı (Half-Adder) devresi\"></p>\n<p><em>Yarım Toplayıcı (Half-Adder) devresi</em></p>\n<p>Bu devreye “<strong>Yarım Toplayıcı</strong>” denilmesinin sebebi işleme bir önceki sonucun eldesini katmıyor olması. Devre çıkış olarak ELDE veriyor, fakat giriş olarak başka bir toplayıcıdan gelen ELDE’yi <strong>dikkate almıyor</strong>.</p>\n<p>O halde <strong>girişlerimize</strong> de bir <strong>ELDE</strong> ekleyip <strong>TAM</strong> bir toplayıcı yapalım :)</p>\n<p><strong>Tam Toplayıcının doğruluk tablosunu çizersek</strong>:</p>\n<p><img src=\"static/img/ram/full-adder-tablosu.png\" alt=\"b1, b2 ve Elde girişine sahip tam toplayıcının doğruluk tablosu\"></p>\n<p><em>b1, b2 ve Elde girişine sahip tam toplayıcının doğruluk tablosu</em></p>\n<p><em>(eveeet işler biraz karıştı değil mi :))</em></p>\n<p><strong>Sonuç</strong> ve <strong>Elde</strong> çıkışlarımızda 1'ler biraz karışık şekilde dağılmış. Örneğin yarım toplayıcıdaki gibi <strong>“Sonuç”</strong> çıkışı için hangi kapı veya kapılar gerekir kestiremiyoruz.</p>\n<h3>O zaman Karnaugh!</h3>\n<p><img src=\"static/img/ram/full-adder-karna.gif\" alt=\"Sonuç ve Elde çıkışlarımızı elde etmek için kullandığımız Karnaugh Haritaları\"></p>\n<p><em>Sonuç ve Elde çıkışlarımızı elde etmek için kullandığımız Karnaugh Haritaları</em></p>\n<p><strong>Elde</strong> ve <strong>Sonuç</strong> çıkışları için; <strong>b1</strong>, <strong>b2</strong> ve <strong>E</strong> girişlerine göre <strong>Karnaugh Haritası</strong> çizersek yukarıdaki gibi iki tane harita elde ederiz.</p>\n<p><em>(Karnaugh’da her çıkış için ayrı tablo çizilir.)</em></p>\n<p>Önemli NOT:</p>\n<blockquote>\n<p>Karnaugh’da sütun veya satırlar sırayla <strong>00–01–10–11</strong> şeklinde <strong>DEĞİL</strong>, <strong>GrayCode</strong> dizilimi olan ve bir sonraki durumla arasında sadece 1 bit fark olan <strong>00–01–11–10</strong> formatında yazılır.\n<strong>GrayCode</strong> formatına göre eğer bir satırda üç tane değişkenimiz olsaydı: <strong>000–001–011–010–110–111–101–100</strong> şeklinde yazacaktık. (iki durum arası sadece 1 bit farklı.)</p>\n</blockquote>\n<h3>Haritanın üzerine niye kutular çizdik ki?</h3>\n<p>Karnaugh Haritalarını özel kılan şey de bu.</p>\n<p>Doğruluk Tablosunda göremediğimiz “1'ler arasındaki ilişkiyi” burada gözle görebiliyoruz, bu da bize <strong>1'leri gruplandırıp</strong>, aynı sonucu verecek devre için <strong>fazladan</strong> kullanacağımız elemanlardan kurtulabilmemizi sağlıyor.</p>\n<p>Mesela <strong>ELDE</strong>’nin haritasındaki mavi kutuyu düşünelim. E b1 b2 sırasıyla yazarsam 101 ve 111 aynı sonucu veriyor <em>(yani 1)</em>. Yani ortadaki değerin (b1) 0 veya 1 olması sonucu etkilemiyor. Bu yüzden b1 girişini devreye katmayıp, <strong>E</strong> ve <strong>b2</strong>'yi bir <strong>VE</strong> kapısına bağlıyoruz.</p>\n<h3>Peki neyi sadeleştirdi bu?</h3>\n<p>Eğer b1'i de kaale alsaydık aynı sonucu elde edebilen şöyle bir devre kurabilirdik:</p>\n<blockquote>\n<p>ELDE = E.<strong>(b1.b2 + b1’.b2)</strong> + …</p>\n</blockquote>\n<p>Halbuki Karnaugh sayesinde yukarıda 5 kapı kullanırken, sadeleştirdiğimiz sonuçta 2 kapı kullanıyoruz:</p>\n<blockquote>\n<p>ELDE = <strong>E.b2</strong> + …</p>\n</blockquote>\n<h2>“ELDE” tablosundaki yan yana üç tane 1'i neden bir grup yapıp daha fazla sadeleştirme yapmadık?</h2>\n<p>Karnaugh Haritalarıda gruplama yaparken elbette belirli kurallarımız var, gruplama yaparken bu kurallara göre yapıyoruz:</p>\n<blockquote>\n<p>*Sadece <strong>2ᶰ katları</strong> kadar 1'ler <strong>gruplanabilir:*</strong></p>\n</blockquote>\n<p><img src=\"static/img/ram/karna-kural1.gif\" alt=\"*Sadece **2ᶰ katları** kadar 1&#x27;ler **gruplanabilir**.*\"></p>\n<blockquote>\n<p>*Gruplamaya önce <strong>en az komşuya sahip</strong> 1'lerden başla:*</p>\n</blockquote>\n<p><img src=\"static/img/ram/karna-kural2.gif\" alt=\"*Gruplamaya önce **en az komşuya sahip** 1&#x27;lerden başla.*\"></p>\n<p>Çok da değil aslında 2 tane mühim kuralımız varmış :)</p>\n<h3>Konumuza geri dönelim: “Tam Toplayıcı”</h3>\n<p>Karnaugh haritasını çizdiğimiz çıkışların denklemlerini yazalım:</p>\n<p><strong>SONUÇ</strong> = E.b1'.b2' + E’.b1'.b2 + E.b1.b2 + E’.b1.b2'\n<strong>ELDE</strong> = E.b2 + E.b1 + b1.b2</p>\n<p>Karnaugh’daki grupları yazdığımızda elde ettiğimiz sonuçlar böyle, fakat yine de tam istediğimiz sadelikte değil. Mantık ilminin matematiksel özelliklerini kullanarak buradan da sadeleştirmeler yapabiliriz.</p>\n<p><strong>SONUÇ</strong> = E.(b1'.b2' + b1.b2) + E’.(b1'.b2 + b1.b2')</p>\n<p>Dikkatli bakarsak 1. parantez içinin XNOR, (00 veya 11 koşulu)</p>\n<ol start=\"2\">\n<li>parantez içinin ise XOR (01 veya 10 koşulu) olduğunu görebiliriz.</li>\n</ol>\n<p>En sade haliyle **SONUÇ **çıkışımızın formülü şöyle olacaktır:</p>\n<p><strong>SONUÇ</strong> = E.(b1 ⊙ b2) + E’.(b1 ⊕ b2)\n<strong>SONUÇ</strong> = E.<strong>(b1 ⊕ b2)’</strong> + E’.(b1 ⊕ b2)</p>\n<blockquote>\n<p>A.B’ + A’.B = A⊕B</p>\n</blockquote>\n<p><strong>SONUÇ</strong> = E ⊕ b1 ⊕ b2\n(2 XOR)</p>\n<p>ELDE çıkışında ise E’leri paranteze alabiliriz:</p>\n<p><strong>ELDE</strong> = E.(b1⊕b2) + b1.b2\n<em>(2 VE, 1 XOR (yukarıdan), 1 VEYA)</em></p>\n<p>Devremizi gerçekleyelim:</p>\n<p><img src=\"static/img/ram/full-adder.gif\"></p>\n<h3>Karnaugh’yı da hallettik!</h3>\n<p>Temel derslerden en önemlisi olarak gördüğüm Karnaugh Haritalarını da bu yazıda bitirelim. <strong>0'dan RAM yapma hedefimize adım adım ilerliyoruz.</strong></p>\n<p>Bir sonraki yazımız olan <a href=\"0-dan-ram-4-kod-cozuculer\"><strong>0 → RAM | 4) Kod çözücüler</strong></a>'de görüşmek üzere.</p>","id":"ebb3cad0-2c8b-595c-99a5-acb67e541238","frontmatter":{"date":"Mart 04, 2020","description":"Mantık devreleri inşa etmek için mühim yöntemlerden birisi \"Karnaugh Haritaları\"","image":"static/img/ram/kapak-ram3.png","path":"/0-dan-ram-3-karnaugh-haritalari","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 3) Karnaugh Haritaları"}},{"excerpt":"Merhabalar! Bu derste mantıksal elektronik devreleri kurmak için olmazsa olmazımız olan Mantık Kapılarına göz atacağız. Mantığın kapısı mı olur? Mantık ilmi, bizim günlük hayatta karar verirken…","html":"<h2>Merhabalar!</h2>\n<p>Bu derste mantıksal elektronik devreleri kurmak için olmazsa olmazımız olan Mantık Kapılarına göz atacağız.</p>\n<h3>Mantığın kapısı mı olur?</h3>\n<p>Mantık ilmi, bizim günlük hayatta <strong>karar</strong> verirken beynimiz ile yaptığımız işlemleri matematiğe uyarlayan bir ilim. Bu ilim pek çok devasa ilim dalının temellerini oluşturuyor.</p>\n<p>Bugün bilgisayarda yaptığımız işlerin büyük çoğunluğu mantıksal çıkarımlar sayesinde olmakta.</p>\n<blockquote>\n<p>Mesela bu yazıyı beğenmek için beğen butonuna tıklamak. Bilgisayar sizin başka bir yere değil de özel olarak o butona tıkladığınızı nasıl anlar ki?</p>\n</blockquote>\n<p><strong>İşte burada mantık ilmi devreye girer.</strong> Kendi aklımızla bir butona tıklama işini nasıl tahayyül ediyorsak onu formülize edip bilgisayarın da aynı şeyi algılamasını sağlayabiliriz.</p>\n<p>Matematikte kullanılan mantıksal işaretler:</p>\n<ul>\n<li><strong>Λ</strong> | <strong>.</strong> | <strong>x</strong> = Ve</li>\n<li><strong>V</strong> | <strong>+</strong> = Veya</li>\n<li><strong>‘</strong> = Değil</li>\n<li><strong>⇒</strong> = İse</li>\n<li>⇔ = Çift yönlü ise (Ancak ve ancak)</li>\n</ul>\n<h3>Bir mantıksal işlem örneği yapalım:</h3>\n<p>Mesela benim aklım o butona basabilmek için 2 şart koşuyor:</p>\n<ol>\n<li>Ekrandaki imleç butonun üzerinde olmalı</li>\n<li>Elimdeki farenin sol tuşuna basmalıyım</li>\n</ol>\n<p>Bu işlemi matematiksel mantık ile yazmak istersek basitçe şöyle yazabiliriz:</p>\n<blockquote>\n<p>A: İmlecin buton üzerinde olması\nB: Farenin sol tuşuna basılması\nButonun tıklanmasına ise C diyelim.\nC, A ve B aynı anda sağlandığında doğru olur. Yani:</p>\n</blockquote>\n<p>C = A ve B</p>\n<p>veya matematiksel olarak ifade edersek.</p>\n<p>C = A Λ B <br>\nC = A.B</p>\n<p>Bu işlemi biraz daha açarsak, A işlemi aslında imlecin koordinatları ile butonun koordinatları arasında bir hesaptan ibaret. Öyleyse şöyle yazabiliriz:</p>\n<p><em>(buradaki b.y b.x gibi '.' kullanımı butonun y,x gibi özelliklerine erişme manasında kullanılmıştır.)</em></p>\n<p><strong>b:</strong> Buton <br>\n<strong>f:</strong> Fare <br>\n<strong>A:</strong> (f.x ≥ b.x) Λ (f.x &#x3C; (b.x + b.genişlik)) Λ (f.y ≥ b.y) Λ (f.y &#x3C; (b.y + b.yükseklik)) <br>\n<strong>B:</strong> f.SolTuşuTıklandıMı <br></p>\n<blockquote>\n<p>Bugün neredeyse bütün tıklanma kontrolleri ve basit çarpışma kontrolü A ve B formülünün 1 veya 0 sonuçlanmasına göre kontrol edilmekte.</p>\n</blockquote>\n<p>Koşullarımızı detaylandırdıysak artık <strong>C = A Λ B</strong> <em>(veya A.B, biz genelde yaygın olan nokta (.) gösterimini kullanacağız)</em> bize butonun tıklanıp tıklanmadığını veren mantıksal formül oldu.</p>\n<h3>Birkaç basit sözlü ifadeyi mantıksal ifadeye çevirelim:</h3>\n<p>“A butonuna basılır ve B butonuna basılmaz ise C koşulu doğrudur”:</p>\n<blockquote>\n<p>C = A.B’</p>\n</blockquote>\n<p>“T düğmesi veya J düğmesine basılırsa K kliması açılsın”:</p>\n<blockquote>\n<p>K = T+J</p>\n</blockquote>\n<p>“O ve P tuşları basılmıyor **veya **O ve P tuşları aynı anda basılıyor ise U koşulu doğrudur”:</p>\n<blockquote>\n<p>U = (O’.P’) + (O.P)</p>\n</blockquote>\n<p>U = (O+P)’ + (O.P) şeklinde de yazılabilir. — “O veya P basılıyor değilse”</p>\n<p>Gördüğünüz gibi mantıksal ifadeler oluşturmak gayet kolay :)</p>\n<p>Mantıksal ifadeler hakkında daha fazla bilgiyi ve bazı matematiksel kuramları <em>(De Morgan Kuralları gibi)</em> pek çok internet sayfasında ve YouTube kanallarında bulabilirsiniz.</p>\n<h3>Mantık güzel, peki “Kapıları” nedir?</h3>\n<p><strong>Mantık Kapıları</strong> yukarıda sadece kağıt üzerinde ifade ettiğimiz mantıksal ifadeleri gerçek hayatta donanımsal olarak gerçekleştirmemize olanak sağlayan elektronik devre elemanlarıdır.</p>\n<blockquote>\n<p>Örneğin bir kumandada iki butona birden basıldığında bir cihazın çalışması</p>\n</blockquote>\n<p>Elektronikte\n“VE kapısı” dediğimiz şey Mantıktaki <strong>Ve (Λ)</strong>’nin,\n“VEYA” kapısı da <strong>Veya (V)</strong>’nın karşılığıdır.</p>\n<p><img src=\"static/img/ram/mantik-kapilari-hepsi.gif\" alt=\"Mantık kapılarının tümü\"></p>\n<p>Çalışma şekilleri yukarıdaki gibi verilmiş kapıların matematiksel olarak da karşılıklarını bilmek isteriz. Çünkü her zaman ezbere iş yapamayız veya ilgilenen ifade git gide karmaşıklaşıp büyüyebilir.</p>\n<p>Bu yüzden <strong>Doğruluk Tablolarını</strong> kullanırız. Doğruluk tabloları bir <strong>elemanın</strong> veya bir <strong>ifadenin</strong> tüm giriş kombinasyonları için çıkışlarını gösterdiğimiz bir tablodan ibaret. Çok basit fakat çok yararlı.</p>\n<h3>Birkaç Doğruluk Tablosu örneği:</h3>\n<p>Mesela A ve B girişlerimiz olsun, bunlardan <strong>sadece bir tanesi</strong> 1 olduğu zaman doğru olan sonuçla Doğruluk Tablosunu çizelim:</p>\n<p><img src=\"static/img/ram/xor-tablo.png\" alt=\"XOR Doğruluk Tablosu\"></p>\n<p>Bu gördüğümüz tablo aslında <strong>Özel VEYA</strong>(XOR veya EXOR) kapısının doğruluk tablosudur.</p>\n<p><strong>Özel VEYA</strong> da örnek ile aynı şeyi gerçekleştirmekte. (yani Farklıysa 1, aynısya 0)</p>\n<p>Elinizdeki duruma göre istediğiniz girişlerde istediğiniz şekilde sonuçlar çıkaran doğruluk tabloları çizebilirsiniz.</p>\n<blockquote>\n<p>Matematiksel olarak ifade edilebilen her doğruluk tablosu gerçeğe dönüştürülebilir.\nBu yüzden bir olayı <strong>doğruluk tablosuna</strong> dökebilmek, onu elektronik ortama aktarabilmek demektir.</p>\n</blockquote>\n<p>Mesela yine A ve B girişlerimiz olsun, fakat şimdi sadece A da B de 1 olduğu zaman sonuç doğru olsun:</p>\n<p><img src=\"static/img/ram/and-tablo.png\" alt=\"AND Doğruluk Tablosu\"></p>\n<p>Bu gördüğümüz tablo da aslında <strong>VE</strong> (AND) kapısının doğruluk tablosudur.</p>\n<p><strong>VE</strong> kapısı sadece iki giriş de <strong>1</strong> olduğu, yani elektrik geldiği zaman 1 olur, sonuç olarak o da elektrik verir.</p>\n<p>Doğruluk Tabloları küçük boyutlarda işimize yarıyor, fakat örneğin elimizde 5 tane durum var ise ne yapacağız? <em>(Bunun için 32 satırlık bir doğruluk tablosu yapmamız gerekir :))</em></p>\n<p><strong>Böyle durumlarda Karnaugh Haritaları kullanırız.</strong> Karnaugh Haritaları doğruluk tablosunun iki boyutlu düzleme dökülmüş halidir. Yani durumlar tek bir sütun kaplamak yerine satır ve sütunlara dağıtılırlar.</p>\n<p><img src=\"static/img/ram/karna1.png\" alt=\"4 Duruma sahip basit bir karnaugh haritası. (Boş alanlar 0)\"><br>\n<em>4 Duruma sahip basit bir karnaugh haritası. (Boş alanlar 0)</em></p>\n<p>Karnaugh Haritalarının bir diğer bir avantajı ise işlemi sadeleştirmenin çok kolay yapılabilmesidir.</p>\n<p>Örneğin biz A ve B’nin sadece 11'de 1 ürettiğini gördüğümüz için kolayca bu tablo tek bir <strong>VE</strong> kapısıyla gerçeklenebilir diyebildik.</p>\n<p><strong>Fakat durum sayısı arttıkça birden fazla kapı gerekebilir. Ve bu durum işlem sadeleştirilmesi yapılmaz ise gereksiz kapı kullanımıyla sonuçlanabilir.</strong></p>\n<p><strong>Bu da daha fazla Masraf+ Boyut + Enerji harcaması demek.</strong></p>\n<blockquote>\n<p>İleride 1 bit veri saklama için kullanacağımız VE-VEYA Mandalı devresi Karnaugh Haritası ile yapılan sadeleştirme ile sadece 3 tane kapıdan oluşmakta.)</p>\n</blockquote>\n<p><strong>Mantık Kapıları</strong> ve <strong>Doğruluk Tablosu</strong>’nu hallettiğimize göre bu yazıyı bitirebiliriz.</p>\n<p>Bir sonraki yazımız olan <a href=\"0-dan-ram-3-karnaugh-haritalari\"><strong>0 → RAM | 3) Karnaugh Haritaları</strong></a>'nda görüşmek üzere!</p>","id":"a43c7591-3fab-5cce-bce4-23d319b757e7","frontmatter":{"date":"Mart 03, 2020","description":"İleride sıkça kullanacağımız mantık kapılarına bir el atalım.","image":"static/img/ram/kapak-ram2.png","path":"/0-dan-ram-2-mantik-kapilari","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 2) Mantık Kapıları"}},{"excerpt":"Merhabalar! (0 → RAM)* *serisinde sizlerle beraber sıfırdan kendi RAM’imizi tasarlayacağız. Bu yazıda tasarıma hemen geçmesek de genel bir bilgi edinmek için okumanız faydalı olacaktır. Başarılar! Ram…","html":"<h2>Merhabalar!</h2>\n<p><strong>(0 → RAM)*</strong> *serisinde sizlerle beraber <strong>sıfırdan</strong> kendi <strong>RAM</strong>’imizi tasarlayacağız. Bu yazıda tasarıma hemen geçmesek de genel bir bilgi edinmek için okumanız faydalı olacaktır. Başarılar!</p>\n<h3>Ram Nedir?</h3>\n<p><strong>R</strong>andom <strong>A</strong>ccess <strong>M</strong>emory, yani Rastgele Erişimli Bellek.</p>\n<p>“Rastgele Erişimli” denilmesinin sebebi bellekteki hafıza bölümlerine “kaotik” veya “neresi rast gelirse” şeklinde erişmemiz değil.</p>\n<p>İstediğimiz (yani herhangi bir, yani rastgele), hafıza bölümüne <strong>tek seferde</strong> erişebildiğimiz için böyle tesmiye edilmiş.</p>\n<p><img src=\"./rastgele-sirali.gif\" alt=\"Bellekteki bir adrese erişim türü farkları [ Rastgele | Sıralı ]\"><em>Bellekteki bir adrese erişim türü farkları [ Rastgele | Sıralı ]</em></p>\n<h3>Ram Ne İşe Yarar?</h3>\n<p>İşlemcimizin en çok konuştuğu donanımlardan biri olan RAM, işlemciye lazım olacak <strong>veriler ve komutları</strong> geçici olarak saklayan ve istenildiğinde de tekrar okumamızı sağlayan bir elektronik devredir.</p>\n<p>Mesela bilgisayarınızda bir program çalıştırdığınız zaman bu program <strong>kalıcı ve yavaş</strong> bellekten okunarak (yani sabit diskinizden) <strong>geçici ve hızlı</strong> (yani RAM) belleğe aktarılır. Daha sonra İşlemci bu programın RAM’de tutulan komutlarını tek tek okuyup çalıştırmaya başlar.</p>\n<blockquote>\n<p>Mesela a ile b’yi topla, RAM’de diğer bir adrese şu veriyi yaz, şu adresteki veriyi 1 arttır gibi komutlar…</p>\n</blockquote>\n<p>İşlemcinin programları sabit diskinizden okuyup çalıştırmama sebebi okuma-yazma hızının çok düşük olmasıdır.</p>\n<blockquote>\n<p>Örneğin ortalama bir <strong>RAM</strong> 15–20GB/s okuma-yazma hızına sahipken, ortalama bir <strong>SSD</strong> 0.4–0.5GB/s hızlarında. ortalama bir <strong>HDD</strong> ise 0.02–0.03GB/s.</p>\n</blockquote>\n<p>Eğer sabit diskten çalıştırsa idi işlemci çok hızlı olmasına rağmen sabit diski sürekli beklemek zorunda kalacaktı, böylece zaman kaybı had safhada olacaktı.</p>\n<h3>“RAM’i anladım, fakat bir veri elektrik ile nasıl saklanabilir ki? Sabit disk üzerindeki kabartılar ile veriyi kolayca saklayabiliyor. Elektrik nasıl saklanır?”</h3>\n<p>Elektrik tek başına saklanabilen bir şey değil evet, ama basit devreler yardımıyla elektriği saklayabiliyoruz.</p>\n<p>Mesela “veri saklama” dediğimiz işini gerçekleştirebilen en basit devrelerden biri <strong>AND-OR Latche</strong> yani <strong>Ve-Veya Mandalı</strong>’dır.</p>\n<p>Bu ismin verilme sebebi sadece 1 VE ve 1 VEYA kapısıyla oluşturulabilmesidir. <em>(bir tane de DEĞİL kapısı var aşağıda tabiki :))</em></p>\n<p><img src=\"./andor-latche.gif\" alt=\"1 bit veri saklayabilen AND-OR-Latche çalışma şekli\"><em>1 bit veri saklayabilen AND-OR-Latche çalışma şekli</em></p>\n<p>Bu devreyi Mantık Devreleri (veya Elektrik Devreleri) tasarlama programları aracılığıyla kendiniz de tasarlayıp simüle edebilirsiniz. Ayrıca ilerideki tasarımlarımızı da kendi bilgisayarınızda gerçeklemek için bu programlara ihtiyacınız olacak.</p>\n<p>Kullanabileceğiniz zordan kolaya sıralı bazı bedava programlar:</p>\n<ul>\n<li><strong>Logisim</strong> (<a href=\"https://sourceforge.net/projects/circuit/\">https://sourceforge.net/projects/circuit/</a>)\n*(Kapsamlılık: 15, Zorluk: 2) <strong><em>kullandığım</em></strong></li>\n<li><strong>Logic Circuit</strong> (<a href=\"https://logiccircuit.org/\">https://logiccircuit.org/</a>)\n<em>(Kapsamlılık: 10, Zorluk: 4)</em></li>\n<li><strong>Logic Circuit Designer</strong> (<a href=\"https://sourceforge.net/projects/logiccircuitd/\">https://sourceforge.net/projects/logiccircuitd/</a>)\n<em>(Kapsamlılık: 7, Zorluk: 2)</em></li>\n<li><strong>Multimedia Logic</strong> (<a href=\"https://sourceforge.net/projects/multimedialogic/\">https://sourceforge.net/projects/multimedialogic/</a>)\n<em>(Kapsamlılık: 4, Zorluk: 1)</em></li>\n</ul>\n<p>Bu devreyi nasıl oluşturacağımız, kapıların nasıl çalıştığı, doğruluk tabloları, karnaugh haritaları gibi teknik meselelere artık başlayabiliriz sanırım.</p>\n<p>Şimdilik bu kadar :)</p>\n<p>Bir sonraki yazımız olan <strong><a href=\"0-dan-ram-2-mantik-kapilari\">0 → RAM | 2) Mantık Kapıları</a></strong>'ında görüşmek üzere!</p>","id":"1e043096-c121-5391-8ff9-e820ff9a0aa2","frontmatter":{"date":"Mart 02, 2020","description":"Sıfırdan RAM tasarladığımız bir seri.","image":"static/img/ram/kapak-ram1.png","path":"/0-dan-ram-1-ram-nedir","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 1) RAM Nedir?"}}],"tag":"RAM"}}}