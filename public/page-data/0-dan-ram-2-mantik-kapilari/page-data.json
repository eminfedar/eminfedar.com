{"componentChunkName":"component---src-templates-blog-post-js","path":"/0-dan-ram-2-mantik-kapilari","result":{"data":{"markdownRemark":{"html":"<h2>Merhabalar!</h2>\n<p>Bu derste mantıksal elektronik devreleri kurmak için olmazsa olmazımız olan Mantık Kapılarına göz atacağız.</p>\n<h3>Mantığın kapısı mı olur?</h3>\n<p>Mantık ilmi, bizim günlük hayatta <strong>karar</strong> verirken beynimiz ile yaptığımız işlemleri matematiğe uyarlayan bir ilim. Bu ilim pek çok devasa ilim dalının temellerini oluşturuyor.</p>\n<p>Bugün bilgisayarda yaptığımız işlerin büyük çoğunluğu mantıksal çıkarımlar sayesinde olmakta.</p>\n<blockquote>\n<p>Mesela bu yazıyı beğenmek için beğen butonuna tıklamak. Bilgisayar sizin başka bir yere değil de özel olarak o butona tıkladığınızı nasıl anlar ki?</p>\n</blockquote>\n<p><strong>İşte burada mantık ilmi devreye girer.</strong> Kendi aklımızla bir butona tıklama işini nasıl tahayyül ediyorsak onu formülize edip bilgisayarın da aynı şeyi algılamasını sağlayabiliriz.</p>\n<p>Matematikte kullanılan mantıksal işaretler:</p>\n<ul>\n<li><strong>Λ</strong> | <strong>.</strong> | <strong>x</strong> = Ve</li>\n<li><strong>V</strong> | <strong>+</strong> = Veya</li>\n<li><strong>‘</strong> = Değil</li>\n<li><strong>⇒</strong> = İse</li>\n<li>⇔ = Çift yönlü ise (Ancak ve ancak)</li>\n</ul>\n<h3>Bir mantıksal işlem örneği yapalım:</h3>\n<p>Mesela benim aklım o butona basabilmek için 2 şart koşuyor:</p>\n<ol>\n<li>Ekrandaki imleç butonun üzerinde olmalı</li>\n<li>Elimdeki farenin sol tuşuna basmalıyım</li>\n</ol>\n<p>Bu işlemi matematiksel mantık ile yazmak istersek basitçe şöyle yazabiliriz:</p>\n<blockquote>\n<p>A: İmlecin buton üzerinde olması\nB: Farenin sol tuşuna basılması\nButonun tıklanmasına ise C diyelim.\nC, A ve B aynı anda sağlandığında doğru olur. Yani:</p>\n</blockquote>\n<p>C = A ve B</p>\n<p>veya matematiksel olarak ifade edersek.</p>\n<p>C = A Λ B <br>\nC = A.B</p>\n<p>Bu işlemi biraz daha açarsak, A işlemi aslında imlecin koordinatları ile butonun koordinatları arasında bir hesaptan ibaret. Öyleyse şöyle yazabiliriz:</p>\n<p><em>(buradaki b.y b.x gibi '.' kullanımı butonun y,x gibi özelliklerine erişme manasında kullanılmıştır.)</em></p>\n<p><strong>b:</strong> Buton <br>\n<strong>f:</strong> Fare <br>\n<strong>A:</strong> (f.x ≥ b.x) Λ (f.x &#x3C; (b.x + b.genişlik)) Λ (f.y ≥ b.y) Λ (f.y &#x3C; (b.y + b.yükseklik)) <br>\n<strong>B:</strong> f.SolTuşuTıklandıMı <br></p>\n<blockquote>\n<p>Bugün neredeyse bütün tıklanma kontrolleri ve basit çarpışma kontrolü A ve B formülünün 1 veya 0 sonuçlanmasına göre kontrol edilmekte.</p>\n</blockquote>\n<p>Koşullarımızı detaylandırdıysak artık <strong>C = A Λ B</strong> <em>(veya A.B, biz genelde yaygın olan nokta (.) gösterimini kullanacağız)</em> bize butonun tıklanıp tıklanmadığını veren mantıksal formül oldu.</p>\n<h3>Birkaç basit sözlü ifadeyi mantıksal ifadeye çevirelim:</h3>\n<p>“A butonuna basılır ve B butonuna basılmaz ise C koşulu doğrudur”:</p>\n<blockquote>\n<p>C = A.B’</p>\n</blockquote>\n<p>“T düğmesi veya J düğmesine basılırsa K kliması açılsın”:</p>\n<blockquote>\n<p>K = T+J</p>\n</blockquote>\n<p>“O ve P tuşları basılmıyor **veya **O ve P tuşları aynı anda basılıyor ise U koşulu doğrudur”:</p>\n<blockquote>\n<p>U = (O’.P’) + (O.P)</p>\n</blockquote>\n<p>U = (O+P)’ + (O.P) şeklinde de yazılabilir. — “O veya P basılıyor değilse”</p>\n<p>Gördüğünüz gibi mantıksal ifadeler oluşturmak gayet kolay :)</p>\n<p>Mantıksal ifadeler hakkında daha fazla bilgiyi ve bazı matematiksel kuramları <em>(De Morgan Kuralları gibi)</em> pek çok internet sayfasında ve YouTube kanallarında bulabilirsiniz.</p>\n<h3>Mantık güzel, peki “Kapıları” nedir?</h3>\n<p><strong>Mantık Kapıları</strong> yukarıda sadece kağıt üzerinde ifade ettiğimiz mantıksal ifadeleri gerçek hayatta donanımsal olarak gerçekleştirmemize olanak sağlayan elektronik devre elemanlarıdır.</p>\n<blockquote>\n<p>Örneğin bir kumandada iki butona birden basıldığında bir cihazın çalışması</p>\n</blockquote>\n<p>Elektronikte\n“VE kapısı” dediğimiz şey Mantıktaki <strong>Ve (Λ)</strong>’nin,\n“VEYA” kapısı da <strong>Veya (V)</strong>’nın karşılığıdır.</p>\n<p><img src=\"static/img/ram/mantik-kapilari-hepsi.gif\" alt=\"Mantık kapılarının tümü\"></p>\n<p>Çalışma şekilleri yukarıdaki gibi verilmiş kapıların matematiksel olarak da karşılıklarını bilmek isteriz. Çünkü her zaman ezbere iş yapamayız veya ilgilenen ifade git gide karmaşıklaşıp büyüyebilir.</p>\n<p>Bu yüzden <strong>Doğruluk Tablolarını</strong> kullanırız. Doğruluk tabloları bir <strong>elemanın</strong> veya bir <strong>ifadenin</strong> tüm giriş kombinasyonları için çıkışlarını gösterdiğimiz bir tablodan ibaret. Çok basit fakat çok yararlı.</p>\n<h3>Birkaç Doğruluk Tablosu örneği:</h3>\n<p>Mesela A ve B girişlerimiz olsun, bunlardan <strong>sadece bir tanesi</strong> 1 olduğu zaman doğru olan sonuçla Doğruluk Tablosunu çizelim:</p>\n<p><img src=\"static/img/ram/xor-tablo.png\" alt=\"XOR Doğruluk Tablosu\"></p>\n<p>Bu gördüğümüz tablo aslında <strong>Özel VEYA</strong>(XOR veya EXOR) kapısının doğruluk tablosudur.</p>\n<p><strong>Özel VEYA</strong> da örnek ile aynı şeyi gerçekleştirmekte. (yani Farklıysa 1, aynısya 0)</p>\n<p>Elinizdeki duruma göre istediğiniz girişlerde istediğiniz şekilde sonuçlar çıkaran doğruluk tabloları çizebilirsiniz.</p>\n<blockquote>\n<p>Matematiksel olarak ifade edilebilen her doğruluk tablosu gerçeğe dönüştürülebilir.\nBu yüzden bir olayı <strong>doğruluk tablosuna</strong> dökebilmek, onu elektronik ortama aktarabilmek demektir.</p>\n</blockquote>\n<p>Mesela yine A ve B girişlerimiz olsun, fakat şimdi sadece A da B de 1 olduğu zaman sonuç doğru olsun:</p>\n<p><img src=\"static/img/ram/and-tablo.png\" alt=\"AND Doğruluk Tablosu\"></p>\n<p>Bu gördüğümüz tablo da aslında <strong>VE</strong> (AND) kapısının doğruluk tablosudur.</p>\n<p><strong>VE</strong> kapısı sadece iki giriş de <strong>1</strong> olduğu, yani elektrik geldiği zaman 1 olur, sonuç olarak o da elektrik verir.</p>\n<p>Doğruluk Tabloları küçük boyutlarda işimize yarıyor, fakat örneğin elimizde 5 tane durum var ise ne yapacağız? <em>(Bunun için 32 satırlık bir doğruluk tablosu yapmamız gerekir :))</em></p>\n<p><strong>Böyle durumlarda Karnaugh Haritaları kullanırız.</strong> Karnaugh Haritaları doğruluk tablosunun iki boyutlu düzleme dökülmüş halidir. Yani durumlar tek bir sütun kaplamak yerine satır ve sütunlara dağıtılırlar.</p>\n<p><img src=\"static/img/ram/karna1.png\" alt=\"4 Duruma sahip basit bir karnaugh haritası. (Boş alanlar 0)\"><br>\n<em>4 Duruma sahip basit bir karnaugh haritası. (Boş alanlar 0)</em></p>\n<p>Karnaugh Haritalarının bir diğer bir avantajı ise işlemi sadeleştirmenin çok kolay yapılabilmesidir.</p>\n<p>Örneğin biz A ve B’nin sadece 11'de 1 ürettiğini gördüğümüz için kolayca bu tablo tek bir <strong>VE</strong> kapısıyla gerçeklenebilir diyebildik.</p>\n<p><strong>Fakat durum sayısı arttıkça birden fazla kapı gerekebilir. Ve bu durum işlem sadeleştirilmesi yapılmaz ise gereksiz kapı kullanımıyla sonuçlanabilir.</strong></p>\n<p><strong>Bu da daha fazla Masraf+ Boyut + Enerji harcaması demek.</strong></p>\n<blockquote>\n<p>İleride 1 bit veri saklama için kullanacağımız VE-VEYA Mandalı devresi Karnaugh Haritası ile yapılan sadeleştirme ile sadece 3 tane kapıdan oluşmakta.)</p>\n</blockquote>\n<p><strong>Mantık Kapıları</strong> ve <strong>Doğruluk Tablosu</strong>’nu hallettiğimize göre bu yazıyı bitirebiliriz.</p>\n<p>Bir sonraki yazımız olan <a href=\"0-dan-ram-3-karnaugh-haritalari\"><strong>0 → RAM | 3) Karnaugh Haritaları</strong></a>'nda görüşmek üzere!</p>","frontmatter":{"date":"Mart 03, 2020","image":"static/img/ram/kapak-ram2.png","path":"/0-dan-ram-2-mantik-kapilari","tags":["RAM"],"title":"0 → RAM | 2) Mantık Kapıları"}}},"pageContext":{"slug":"/0-dan-ram-2-mantik-kapilari","previous":{"excerpt":"Merhabalar! (0 → RAM)* *serisinde sizlerle beraber sıfırdan kendi RAM’imizi tasarlayacağız. Bu yazıda tasarıma hemen geçmesek de genel bir bilgi edinmek için okumanız faydalı olacaktır. Başarılar! Ram…","html":"<h2>Merhabalar!</h2>\n<p><strong>(0 → RAM)*</strong> *serisinde sizlerle beraber <strong>sıfırdan</strong> kendi <strong>RAM</strong>’imizi tasarlayacağız. Bu yazıda tasarıma hemen geçmesek de genel bir bilgi edinmek için okumanız faydalı olacaktır. Başarılar!</p>\n<h3>Ram Nedir?</h3>\n<p><strong>R</strong>andom <strong>A</strong>ccess <strong>M</strong>emory, yani Rastgele Erişimli Bellek.</p>\n<p>“Rastgele Erişimli” denilmesinin sebebi bellekteki hafıza bölümlerine “kaotik” veya “neresi rast gelirse” şeklinde erişmemiz değil.</p>\n<p>İstediğimiz (yani herhangi bir, yani rastgele), hafıza bölümüne <strong>tek seferde</strong> erişebildiğimiz için böyle tesmiye edilmiş.</p>\n<p><img src=\"./rastgele-sirali.gif\" alt=\"Bellekteki bir adrese erişim türü farkları [ Rastgele | Sıralı ]\"><em>Bellekteki bir adrese erişim türü farkları [ Rastgele | Sıralı ]</em></p>\n<h3>Ram Ne İşe Yarar?</h3>\n<p>İşlemcimizin en çok konuştuğu donanımlardan biri olan RAM, işlemciye lazım olacak <strong>veriler ve komutları</strong> geçici olarak saklayan ve istenildiğinde de tekrar okumamızı sağlayan bir elektronik devredir.</p>\n<p>Mesela bilgisayarınızda bir program çalıştırdığınız zaman bu program <strong>kalıcı ve yavaş</strong> bellekten okunarak (yani sabit diskinizden) <strong>geçici ve hızlı</strong> (yani RAM) belleğe aktarılır. Daha sonra İşlemci bu programın RAM’de tutulan komutlarını tek tek okuyup çalıştırmaya başlar.</p>\n<blockquote>\n<p>Mesela a ile b’yi topla, RAM’de diğer bir adrese şu veriyi yaz, şu adresteki veriyi 1 arttır gibi komutlar…</p>\n</blockquote>\n<p>İşlemcinin programları sabit diskinizden okuyup çalıştırmama sebebi okuma-yazma hızının çok düşük olmasıdır.</p>\n<blockquote>\n<p>Örneğin ortalama bir <strong>RAM</strong> 15–20GB/s okuma-yazma hızına sahipken, ortalama bir <strong>SSD</strong> 0.4–0.5GB/s hızlarında. ortalama bir <strong>HDD</strong> ise 0.02–0.03GB/s.</p>\n</blockquote>\n<p>Eğer sabit diskten çalıştırsa idi işlemci çok hızlı olmasına rağmen sabit diski sürekli beklemek zorunda kalacaktı, böylece zaman kaybı had safhada olacaktı.</p>\n<h3>“RAM’i anladım, fakat bir veri elektrik ile nasıl saklanabilir ki? Sabit disk üzerindeki kabartılar ile veriyi kolayca saklayabiliyor. Elektrik nasıl saklanır?”</h3>\n<p>Elektrik tek başına saklanabilen bir şey değil evet, ama basit devreler yardımıyla elektriği saklayabiliyoruz.</p>\n<p>Mesela “veri saklama” dediğimiz işini gerçekleştirebilen en basit devrelerden biri <strong>AND-OR Latche</strong> yani <strong>Ve-Veya Mandalı</strong>’dır.</p>\n<p>Bu ismin verilme sebebi sadece 1 VE ve 1 VEYA kapısıyla oluşturulabilmesidir. <em>(bir tane de DEĞİL kapısı var aşağıda tabiki :))</em></p>\n<p><img src=\"./andor-latche.gif\" alt=\"1 bit veri saklayabilen AND-OR-Latche çalışma şekli\"><em>1 bit veri saklayabilen AND-OR-Latche çalışma şekli</em></p>\n<p>Bu devreyi Mantık Devreleri (veya Elektrik Devreleri) tasarlama programları aracılığıyla kendiniz de tasarlayıp simüle edebilirsiniz. Ayrıca ilerideki tasarımlarımızı da kendi bilgisayarınızda gerçeklemek için bu programlara ihtiyacınız olacak.</p>\n<p>Kullanabileceğiniz zordan kolaya sıralı bazı bedava programlar:</p>\n<ul>\n<li><strong>Logisim</strong> (<a href=\"https://sourceforge.net/projects/circuit/\">https://sourceforge.net/projects/circuit/</a>)\n*(Kapsamlılık: 15, Zorluk: 2) <strong><em>kullandığım</em></strong></li>\n<li><strong>Logic Circuit</strong> (<a href=\"https://logiccircuit.org/\">https://logiccircuit.org/</a>)\n<em>(Kapsamlılık: 10, Zorluk: 4)</em></li>\n<li><strong>Logic Circuit Designer</strong> (<a href=\"https://sourceforge.net/projects/logiccircuitd/\">https://sourceforge.net/projects/logiccircuitd/</a>)\n<em>(Kapsamlılık: 7, Zorluk: 2)</em></li>\n<li><strong>Multimedia Logic</strong> (<a href=\"https://sourceforge.net/projects/multimedialogic/\">https://sourceforge.net/projects/multimedialogic/</a>)\n<em>(Kapsamlılık: 4, Zorluk: 1)</em></li>\n</ul>\n<p>Bu devreyi nasıl oluşturacağımız, kapıların nasıl çalıştığı, doğruluk tabloları, karnaugh haritaları gibi teknik meselelere artık başlayabiliriz sanırım.</p>\n<p>Şimdilik bu kadar :)</p>\n<p>Bir sonraki yazımız olan <strong><a href=\"0-dan-ram-2-mantik-kapilari\">0 → RAM | 2) Mantık Kapıları</a></strong>'ında görüşmek üzere!</p>","id":"1e043096-c121-5391-8ff9-e820ff9a0aa2","frontmatter":{"date":"Mart 02, 2020","description":"Sıfırdan RAM tasarladığımız bir seri.","image":"static/img/ram/kapak-ram1.png","path":"/0-dan-ram-1-ram-nedir","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 1) RAM Nedir?"}},"next":{"excerpt":"Merhabalar! Önceki derste Mantık Kapılarına ve Doğruluk Tablolarına giriş yapmıştık. Doğruluk Tabloları güzeldi fakat bir eksiği vardı ki; kapı sayısı arttıkça Doğruluk Tablolarının çekilemez…","html":"<h2>Merhabalar!</h2>\n<p>Önceki derste <strong>Mantık Kapıları</strong>na ve <strong>Doğruluk Tabloları</strong>na giriş yapmıştık. Doğruluk Tabloları güzeldi fakat bir eksiği vardı ki; kapı sayısı arttıkça <strong>Doğruluk Tabloları</strong>nın çekilemez uzunluklara ulaşması ve sadeleştirme işlemlerinin biraz daha zor görülmesiydi.</p>\n<p>İşte bu sıkıntıları çekmemek için Maurice Karnaugh ve Edward Veitch’in güzel bir çalışması olan Karnaugh (Karnaugh-Veitch) Haritalarını kullanacağız.</p>\n<h2>Karnaugh Haritaları (Karnaugh-Veitch Maps)</h2>\n<p>Karnaugh Haritaları basitçe doğruluk tablosunun aşağıya doğru uzayan hali yerine <strong>iki boyutlu bir tablo</strong> haline getirilmesinden ibaret. <strong>Fakat bize sağladığı kolaylıklar çok fazla. :)</strong></p>\n<h3>Bir örnek yapalım:</h3>\n<p>Örneğimiz bir toplayıcı devresi olsun. Devremizde <strong>Bit-1</strong>, <strong>Bit-2</strong> butonları (girişleri) ve <strong>SONUÇ</strong> ve <strong>ELDE</strong> çıkışları (buralara LED bağlayabiliriz) olsun.</p>\n<p>Gireceğimiz iki biti toplayan ve eğer <strong>elde <em>(carry)</em></strong> değeri elde edersek <strong>ELDE</strong> çıkışını 1 yapan <em>(amma çok elde kelimesi geçti… :))</em>, toplama sounucunu da <strong>SONUÇ</strong> çıkışına veren bir devre yapalım. Bu devrenin doğruluk tablosunu çizersek şöyle bir sonuç elde ederiz:</p>\n<p><img src=\"static/img/ram/half-adder-tablosu.png\" alt=\"Yarım Toplayıcı(Half-Adder) Doğruluk Tablosu\"><em>Yarım Toplayıcı(Half-Adder) Doğruluk Tablosu</em></p>\n<p><strong>“Sonuç”</strong> çıkışı görebileceğimiz üzere bir <strong>Özel VEYA</strong> (XOR) kapısı ile gerçeklenebilir, çünkü sadece tet bir bit <strong>1</strong> olduğu zaman çıkış <strong>1</strong>.</p>\n<blockquote>\n<p>XOR: ⊕</p>\n<p>XNOR: ⊙</p>\n</blockquote>\n<p><strong>“Elde”</strong> çıkışımız ise sadece iki bit de 1 olduğu zaman 1 oluyor. O halde Elde çıkışı bir <strong>VE</strong> kapısı ile gerçeklenebilir. Bu durumda devremizin Sonuç çıkışının mantık kapılarıyla formülünü çıkarmak istersek:</p>\n<blockquote>\n<p><strong>Sonuç</strong> = <strong>b1 ⊕ b2</strong></p>\n<p><strong>Elde</strong> = <strong>b1 . b2</strong></p>\n</blockquote>\n<p>Tebrikler, bir <strong>Yarım Toplayıcı</strong> yaptınız :)</p>\n<h2>İyi de neden “Yarım” oldu ki?</h2>\n<p><img src=\"static/img/ram/half-adder.gif\" alt=\"Yarım Toplayıcı (Half-Adder) devresi\"></p>\n<p><em>Yarım Toplayıcı (Half-Adder) devresi</em></p>\n<p>Bu devreye “<strong>Yarım Toplayıcı</strong>” denilmesinin sebebi işleme bir önceki sonucun eldesini katmıyor olması. Devre çıkış olarak ELDE veriyor, fakat giriş olarak başka bir toplayıcıdan gelen ELDE’yi <strong>dikkate almıyor</strong>.</p>\n<p>O halde <strong>girişlerimize</strong> de bir <strong>ELDE</strong> ekleyip <strong>TAM</strong> bir toplayıcı yapalım :)</p>\n<p><strong>Tam Toplayıcının doğruluk tablosunu çizersek</strong>:</p>\n<p><img src=\"static/img/ram/full-adder-tablosu.png\" alt=\"b1, b2 ve Elde girişine sahip tam toplayıcının doğruluk tablosu\"></p>\n<p><em>b1, b2 ve Elde girişine sahip tam toplayıcının doğruluk tablosu</em></p>\n<p><em>(eveeet işler biraz karıştı değil mi :))</em></p>\n<p><strong>Sonuç</strong> ve <strong>Elde</strong> çıkışlarımızda 1'ler biraz karışık şekilde dağılmış. Örneğin yarım toplayıcıdaki gibi <strong>“Sonuç”</strong> çıkışı için hangi kapı veya kapılar gerekir kestiremiyoruz.</p>\n<h3>O zaman Karnaugh!</h3>\n<p><img src=\"static/img/ram/full-adder-karna.gif\" alt=\"Sonuç ve Elde çıkışlarımızı elde etmek için kullandığımız Karnaugh Haritaları\"></p>\n<p><em>Sonuç ve Elde çıkışlarımızı elde etmek için kullandığımız Karnaugh Haritaları</em></p>\n<p><strong>Elde</strong> ve <strong>Sonuç</strong> çıkışları için; <strong>b1</strong>, <strong>b2</strong> ve <strong>E</strong> girişlerine göre <strong>Karnaugh Haritası</strong> çizersek yukarıdaki gibi iki tane harita elde ederiz.</p>\n<p><em>(Karnaugh’da her çıkış için ayrı tablo çizilir.)</em></p>\n<p>Önemli NOT:</p>\n<blockquote>\n<p>Karnaugh’da sütun veya satırlar sırayla <strong>00–01–10–11</strong> şeklinde <strong>DEĞİL</strong>, <strong>GrayCode</strong> dizilimi olan ve bir sonraki durumla arasında sadece 1 bit fark olan <strong>00–01–11–10</strong> formatında yazılır.\n<strong>GrayCode</strong> formatına göre eğer bir satırda üç tane değişkenimiz olsaydı: <strong>000–001–011–010–110–111–101–100</strong> şeklinde yazacaktık. (iki durum arası sadece 1 bit farklı.)</p>\n</blockquote>\n<h3>Haritanın üzerine niye kutular çizdik ki?</h3>\n<p>Karnaugh Haritalarını özel kılan şey de bu.</p>\n<p>Doğruluk Tablosunda göremediğimiz “1'ler arasındaki ilişkiyi” burada gözle görebiliyoruz, bu da bize <strong>1'leri gruplandırıp</strong>, aynı sonucu verecek devre için <strong>fazladan</strong> kullanacağımız elemanlardan kurtulabilmemizi sağlıyor.</p>\n<p>Mesela <strong>ELDE</strong>’nin haritasındaki mavi kutuyu düşünelim. E b1 b2 sırasıyla yazarsam 101 ve 111 aynı sonucu veriyor <em>(yani 1)</em>. Yani ortadaki değerin (b1) 0 veya 1 olması sonucu etkilemiyor. Bu yüzden b1 girişini devreye katmayıp, <strong>E</strong> ve <strong>b2</strong>'yi bir <strong>VE</strong> kapısına bağlıyoruz.</p>\n<h3>Peki neyi sadeleştirdi bu?</h3>\n<p>Eğer b1'i de kaale alsaydık aynı sonucu elde edebilen şöyle bir devre kurabilirdik:</p>\n<blockquote>\n<p>ELDE = E.<strong>(b1.b2 + b1’.b2)</strong> + …</p>\n</blockquote>\n<p>Halbuki Karnaugh sayesinde yukarıda 5 kapı kullanırken, sadeleştirdiğimiz sonuçta 2 kapı kullanıyoruz:</p>\n<blockquote>\n<p>ELDE = <strong>E.b2</strong> + …</p>\n</blockquote>\n<h2>“ELDE” tablosundaki yan yana üç tane 1'i neden bir grup yapıp daha fazla sadeleştirme yapmadık?</h2>\n<p>Karnaugh Haritalarıda gruplama yaparken elbette belirli kurallarımız var, gruplama yaparken bu kurallara göre yapıyoruz:</p>\n<blockquote>\n<p>*Sadece <strong>2ᶰ katları</strong> kadar 1'ler <strong>gruplanabilir:*</strong></p>\n</blockquote>\n<p><img src=\"static/img/ram/karna-kural1.gif\" alt=\"*Sadece **2ᶰ katları** kadar 1&#x27;ler **gruplanabilir**.*\"></p>\n<blockquote>\n<p>*Gruplamaya önce <strong>en az komşuya sahip</strong> 1'lerden başla:*</p>\n</blockquote>\n<p><img src=\"static/img/ram/karna-kural2.gif\" alt=\"*Gruplamaya önce **en az komşuya sahip** 1&#x27;lerden başla.*\"></p>\n<p>Çok da değil aslında 2 tane mühim kuralımız varmış :)</p>\n<h3>Konumuza geri dönelim: “Tam Toplayıcı”</h3>\n<p>Karnaugh haritasını çizdiğimiz çıkışların denklemlerini yazalım:</p>\n<p><strong>SONUÇ</strong> = E.b1'.b2' + E’.b1'.b2 + E.b1.b2 + E’.b1.b2'\n<strong>ELDE</strong> = E.b2 + E.b1 + b1.b2</p>\n<p>Karnaugh’daki grupları yazdığımızda elde ettiğimiz sonuçlar böyle, fakat yine de tam istediğimiz sadelikte değil. Mantık ilminin matematiksel özelliklerini kullanarak buradan da sadeleştirmeler yapabiliriz.</p>\n<p><strong>SONUÇ</strong> = E.(b1'.b2' + b1.b2) + E’.(b1'.b2 + b1.b2')</p>\n<p>Dikkatli bakarsak 1. parantez içinin XNOR, (00 veya 11 koşulu)</p>\n<ol start=\"2\">\n<li>parantez içinin ise XOR (01 veya 10 koşulu) olduğunu görebiliriz.</li>\n</ol>\n<p>En sade haliyle **SONUÇ **çıkışımızın formülü şöyle olacaktır:</p>\n<p><strong>SONUÇ</strong> = E.(b1 ⊙ b2) + E’.(b1 ⊕ b2)\n<strong>SONUÇ</strong> = E.<strong>(b1 ⊕ b2)’</strong> + E’.(b1 ⊕ b2)</p>\n<blockquote>\n<p>A.B’ + A’.B = A⊕B</p>\n</blockquote>\n<p><strong>SONUÇ</strong> = E ⊕ b1 ⊕ b2\n(2 XOR)</p>\n<p>ELDE çıkışında ise E’leri paranteze alabiliriz:</p>\n<p><strong>ELDE</strong> = E.(b1⊕b2) + b1.b2\n<em>(2 VE, 1 XOR (yukarıdan), 1 VEYA)</em></p>\n<p>Devremizi gerçekleyelim:</p>\n<p><img src=\"static/img/ram/full-adder.gif\"></p>\n<h3>Karnaugh’yı da hallettik!</h3>\n<p>Temel derslerden en önemlisi olarak gördüğüm Karnaugh Haritalarını da bu yazıda bitirelim. <strong>0'dan RAM yapma hedefimize adım adım ilerliyoruz.</strong></p>\n<p>Bir sonraki yazımız olan <a href=\"0-dan-ram-4-kod-cozuculer\"><strong>0 → RAM | 4) Kod çözücüler</strong></a>'de görüşmek üzere.</p>","id":"ebb3cad0-2c8b-595c-99a5-acb67e541238","frontmatter":{"date":"Mart 04, 2020","description":"Mantık devreleri inşa etmek için mühim yöntemlerden birisi \"Karnaugh Haritaları\"","image":"static/img/ram/kapak-ram3.png","path":"/0-dan-ram-3-karnaugh-haritalari","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 3) Karnaugh Haritaları"}}}}}