{"componentChunkName":"component---src-templates-blog-post-js","path":"/0-dan-ram-3-karnaugh-haritalari","result":{"data":{"markdownRemark":{"html":"<h2>Merhabalar!</h2>\n<p>Önceki derste <strong>Mantık Kapıları</strong>na ve <strong>Doğruluk Tabloları</strong>na giriş yapmıştık. Doğruluk Tabloları güzeldi fakat bir eksiği vardı ki; kapı sayısı arttıkça <strong>Doğruluk Tabloları</strong>nın çekilemez uzunluklara ulaşması ve sadeleştirme işlemlerinin biraz daha zor görülmesiydi.</p>\n<p>İşte bu sıkıntıları çekmemek için Maurice Karnaugh ve Edward Veitch’in güzel bir çalışması olan Karnaugh (Karnaugh-Veitch) Haritalarını kullanacağız.</p>\n<h2>Karnaugh Haritaları (Karnaugh-Veitch Maps)</h2>\n<p>Karnaugh Haritaları basitçe doğruluk tablosunun aşağıya doğru uzayan hali yerine <strong>iki boyutlu bir tablo</strong> haline getirilmesinden ibaret. <strong>Fakat bize sağladığı kolaylıklar çok fazla. :)</strong></p>\n<h3>Bir örnek yapalım:</h3>\n<p>Örneğimiz bir toplayıcı devresi olsun. Devremizde <strong>Bit-1</strong>, <strong>Bit-2</strong> butonları (girişleri) ve <strong>SONUÇ</strong> ve <strong>ELDE</strong> çıkışları (buralara LED bağlayabiliriz) olsun.</p>\n<p>Gireceğimiz iki biti toplayan ve eğer <strong>elde <em>(carry)</em></strong> değeri elde edersek <strong>ELDE</strong> çıkışını 1 yapan <em>(amma çok elde kelimesi geçti… :))</em>, toplama sounucunu da <strong>SONUÇ</strong> çıkışına veren bir devre yapalım. Bu devrenin doğruluk tablosunu çizersek şöyle bir sonuç elde ederiz:</p>\n<p><img src=\"static/img/ram/half-adder-tablosu.png\" alt=\"Yarım Toplayıcı(Half-Adder) Doğruluk Tablosu\"><em>Yarım Toplayıcı(Half-Adder) Doğruluk Tablosu</em></p>\n<p><strong>“Sonuç”</strong> çıkışı görebileceğimiz üzere bir <strong>Özel VEYA</strong> (XOR) kapısı ile gerçeklenebilir, çünkü sadece tet bir bit <strong>1</strong> olduğu zaman çıkış <strong>1</strong>.</p>\n<blockquote>\n<p>XOR: ⊕</p>\n<p>XNOR: ⊙</p>\n</blockquote>\n<p><strong>“Elde”</strong> çıkışımız ise sadece iki bit de 1 olduğu zaman 1 oluyor. O halde Elde çıkışı bir <strong>VE</strong> kapısı ile gerçeklenebilir. Bu durumda devremizin Sonuç çıkışının mantık kapılarıyla formülünü çıkarmak istersek:</p>\n<blockquote>\n<p><strong>Sonuç</strong> = <strong>b1 ⊕ b2</strong></p>\n<p><strong>Elde</strong> = <strong>b1 . b2</strong></p>\n</blockquote>\n<p>Tebrikler, bir <strong>Yarım Toplayıcı</strong> yaptınız :)</p>\n<h2>İyi de neden “Yarım” oldu ki?</h2>\n<p><img src=\"static/img/ram/half-adder.gif\" alt=\"Yarım Toplayıcı (Half-Adder) devresi\"></p>\n<p><em>Yarım Toplayıcı (Half-Adder) devresi</em></p>\n<p>Bu devreye “<strong>Yarım Toplayıcı</strong>” denilmesinin sebebi işleme bir önceki sonucun eldesini katmıyor olması. Devre çıkış olarak ELDE veriyor, fakat giriş olarak başka bir toplayıcıdan gelen ELDE’yi <strong>dikkate almıyor</strong>.</p>\n<p>O halde <strong>girişlerimize</strong> de bir <strong>ELDE</strong> ekleyip <strong>TAM</strong> bir toplayıcı yapalım :)</p>\n<p><strong>Tam Toplayıcının doğruluk tablosunu çizersek</strong>:</p>\n<p><img src=\"static/img/ram/full-adder-tablosu.png\" alt=\"b1, b2 ve Elde girişine sahip tam toplayıcının doğruluk tablosu\"></p>\n<p><em>b1, b2 ve Elde girişine sahip tam toplayıcının doğruluk tablosu</em></p>\n<p><em>(eveeet işler biraz karıştı değil mi :))</em></p>\n<p><strong>Sonuç</strong> ve <strong>Elde</strong> çıkışlarımızda 1'ler biraz karışık şekilde dağılmış. Örneğin yarım toplayıcıdaki gibi <strong>“Sonuç”</strong> çıkışı için hangi kapı veya kapılar gerekir kestiremiyoruz.</p>\n<h3>O zaman Karnaugh!</h3>\n<p><img src=\"static/img/ram/full-adder-karna.gif\" alt=\"Sonuç ve Elde çıkışlarımızı elde etmek için kullandığımız Karnaugh Haritaları\"></p>\n<p><em>Sonuç ve Elde çıkışlarımızı elde etmek için kullandığımız Karnaugh Haritaları</em></p>\n<p><strong>Elde</strong> ve <strong>Sonuç</strong> çıkışları için; <strong>b1</strong>, <strong>b2</strong> ve <strong>E</strong> girişlerine göre <strong>Karnaugh Haritası</strong> çizersek yukarıdaki gibi iki tane harita elde ederiz.</p>\n<p><em>(Karnaugh’da her çıkış için ayrı tablo çizilir.)</em></p>\n<p>Önemli NOT:</p>\n<blockquote>\n<p>Karnaugh’da sütun veya satırlar sırayla <strong>00–01–10–11</strong> şeklinde <strong>DEĞİL</strong>, <strong>GrayCode</strong> dizilimi olan ve bir sonraki durumla arasında sadece 1 bit fark olan <strong>00–01–11–10</strong> formatında yazılır.\n<strong>GrayCode</strong> formatına göre eğer bir satırda üç tane değişkenimiz olsaydı: <strong>000–001–011–010–110–111–101–100</strong> şeklinde yazacaktık. (iki durum arası sadece 1 bit farklı.)</p>\n</blockquote>\n<h3>Haritanın üzerine niye kutular çizdik ki?</h3>\n<p>Karnaugh Haritalarını özel kılan şey de bu.</p>\n<p>Doğruluk Tablosunda göremediğimiz “1'ler arasındaki ilişkiyi” burada gözle görebiliyoruz, bu da bize <strong>1'leri gruplandırıp</strong>, aynı sonucu verecek devre için <strong>fazladan</strong> kullanacağımız elemanlardan kurtulabilmemizi sağlıyor.</p>\n<p>Mesela <strong>ELDE</strong>’nin haritasındaki mavi kutuyu düşünelim. E b1 b2 sırasıyla yazarsam 101 ve 111 aynı sonucu veriyor <em>(yani 1)</em>. Yani ortadaki değerin (b1) 0 veya 1 olması sonucu etkilemiyor. Bu yüzden b1 girişini devreye katmayıp, <strong>E</strong> ve <strong>b2</strong>'yi bir <strong>VE</strong> kapısına bağlıyoruz.</p>\n<h3>Peki neyi sadeleştirdi bu?</h3>\n<p>Eğer b1'i de kaale alsaydık aynı sonucu elde edebilen şöyle bir devre kurabilirdik:</p>\n<blockquote>\n<p>ELDE = E.<strong>(b1.b2 + b1’.b2)</strong> + …</p>\n</blockquote>\n<p>Halbuki Karnaugh sayesinde yukarıda 5 kapı kullanırken, sadeleştirdiğimiz sonuçta 2 kapı kullanıyoruz:</p>\n<blockquote>\n<p>ELDE = <strong>E.b2</strong> + …</p>\n</blockquote>\n<h2>“ELDE” tablosundaki yan yana üç tane 1'i neden bir grup yapıp daha fazla sadeleştirme yapmadık?</h2>\n<p>Karnaugh Haritalarıda gruplama yaparken elbette belirli kurallarımız var, gruplama yaparken bu kurallara göre yapıyoruz:</p>\n<blockquote>\n<p>*Sadece <strong>2ᶰ katları</strong> kadar 1'ler <strong>gruplanabilir:*</strong></p>\n</blockquote>\n<p><img src=\"static/img/ram/karna-kural1.gif\" alt=\"*Sadece **2ᶰ katları** kadar 1&#x27;ler **gruplanabilir**.*\"></p>\n<blockquote>\n<p>*Gruplamaya önce <strong>en az komşuya sahip</strong> 1'lerden başla:*</p>\n</blockquote>\n<p><img src=\"static/img/ram/karna-kural2.gif\" alt=\"*Gruplamaya önce **en az komşuya sahip** 1&#x27;lerden başla.*\"></p>\n<p>Çok da değil aslında 2 tane mühim kuralımız varmış :)</p>\n<h3>Konumuza geri dönelim: “Tam Toplayıcı”</h3>\n<p>Karnaugh haritasını çizdiğimiz çıkışların denklemlerini yazalım:</p>\n<p><strong>SONUÇ</strong> = E.b1'.b2' + E’.b1'.b2 + E.b1.b2 + E’.b1.b2'\n<strong>ELDE</strong> = E.b2 + E.b1 + b1.b2</p>\n<p>Karnaugh’daki grupları yazdığımızda elde ettiğimiz sonuçlar böyle, fakat yine de tam istediğimiz sadelikte değil. Mantık ilminin matematiksel özelliklerini kullanarak buradan da sadeleştirmeler yapabiliriz.</p>\n<p><strong>SONUÇ</strong> = E.(b1'.b2' + b1.b2) + E’.(b1'.b2 + b1.b2')</p>\n<p>Dikkatli bakarsak 1. parantez içinin XNOR, (00 veya 11 koşulu)</p>\n<ol start=\"2\">\n<li>parantez içinin ise XOR (01 veya 10 koşulu) olduğunu görebiliriz.</li>\n</ol>\n<p>En sade haliyle **SONUÇ **çıkışımızın formülü şöyle olacaktır:</p>\n<p><strong>SONUÇ</strong> = E.(b1 ⊙ b2) + E’.(b1 ⊕ b2)\n<strong>SONUÇ</strong> = E.<strong>(b1 ⊕ b2)’</strong> + E’.(b1 ⊕ b2)</p>\n<blockquote>\n<p>A.B’ + A’.B = A⊕B</p>\n</blockquote>\n<p><strong>SONUÇ</strong> = E ⊕ b1 ⊕ b2\n(2 XOR)</p>\n<p>ELDE çıkışında ise E’leri paranteze alabiliriz:</p>\n<p><strong>ELDE</strong> = E.(b1⊕b2) + b1.b2\n<em>(2 VE, 1 XOR (yukarıdan), 1 VEYA)</em></p>\n<p>Devremizi gerçekleyelim:</p>\n<p><img src=\"static/img/ram/full-adder.gif\"></p>\n<h3>Karnaugh’yı da hallettik!</h3>\n<p>Temel derslerden en önemlisi olarak gördüğüm Karnaugh Haritalarını da bu yazıda bitirelim. <strong>0'dan RAM yapma hedefimize adım adım ilerliyoruz.</strong></p>\n<p>Bir sonraki yazımız olan <a href=\"0-dan-ram-4-kod-cozuculer\"><strong>0 → RAM | 4) Kod çözücüler</strong></a>'de görüşmek üzere.</p>","frontmatter":{"date":"Mart 04, 2020","image":"static/img/ram/kapak-ram3.png","path":"/0-dan-ram-3-karnaugh-haritalari","tags":["RAM"],"title":"0 → RAM | 3) Karnaugh Haritaları"}}},"pageContext":{"slug":"/0-dan-ram-3-karnaugh-haritalari","previous":{"excerpt":"Merhabalar! Bu derste mantıksal elektronik devreleri kurmak için olmazsa olmazımız olan Mantık Kapılarına göz atacağız. Mantığın kapısı mı olur? Mantık ilmi, bizim günlük hayatta karar verirken…","html":"<h2>Merhabalar!</h2>\n<p>Bu derste mantıksal elektronik devreleri kurmak için olmazsa olmazımız olan Mantık Kapılarına göz atacağız.</p>\n<h3>Mantığın kapısı mı olur?</h3>\n<p>Mantık ilmi, bizim günlük hayatta <strong>karar</strong> verirken beynimiz ile yaptığımız işlemleri matematiğe uyarlayan bir ilim. Bu ilim pek çok devasa ilim dalının temellerini oluşturuyor.</p>\n<p>Bugün bilgisayarda yaptığımız işlerin büyük çoğunluğu mantıksal çıkarımlar sayesinde olmakta.</p>\n<blockquote>\n<p>Mesela bu yazıyı beğenmek için beğen butonuna tıklamak. Bilgisayar sizin başka bir yere değil de özel olarak o butona tıkladığınızı nasıl anlar ki?</p>\n</blockquote>\n<p><strong>İşte burada mantık ilmi devreye girer.</strong> Kendi aklımızla bir butona tıklama işini nasıl tahayyül ediyorsak onu formülize edip bilgisayarın da aynı şeyi algılamasını sağlayabiliriz.</p>\n<p>Matematikte kullanılan mantıksal işaretler:</p>\n<ul>\n<li><strong>Λ</strong> | <strong>.</strong> | <strong>x</strong> = Ve</li>\n<li><strong>V</strong> | <strong>+</strong> = Veya</li>\n<li><strong>‘</strong> = Değil</li>\n<li><strong>⇒</strong> = İse</li>\n<li>⇔ = Çift yönlü ise (Ancak ve ancak)</li>\n</ul>\n<h3>Bir mantıksal işlem örneği yapalım:</h3>\n<p>Mesela benim aklım o butona basabilmek için 2 şart koşuyor:</p>\n<ol>\n<li>Ekrandaki imleç butonun üzerinde olmalı</li>\n<li>Elimdeki farenin sol tuşuna basmalıyım</li>\n</ol>\n<p>Bu işlemi matematiksel mantık ile yazmak istersek basitçe şöyle yazabiliriz:</p>\n<blockquote>\n<p>A: İmlecin buton üzerinde olması\nB: Farenin sol tuşuna basılması\nButonun tıklanmasına ise C diyelim.\nC, A ve B aynı anda sağlandığında doğru olur. Yani:</p>\n</blockquote>\n<p>C = A ve B</p>\n<p>veya matematiksel olarak ifade edersek.</p>\n<p>C = A Λ B <br>\nC = A.B</p>\n<p>Bu işlemi biraz daha açarsak, A işlemi aslında imlecin koordinatları ile butonun koordinatları arasında bir hesaptan ibaret. Öyleyse şöyle yazabiliriz:</p>\n<p><em>(buradaki b.y b.x gibi '.' kullanımı butonun y,x gibi özelliklerine erişme manasında kullanılmıştır.)</em></p>\n<p><strong>b:</strong> Buton <br>\n<strong>f:</strong> Fare <br>\n<strong>A:</strong> (f.x ≥ b.x) Λ (f.x &#x3C; (b.x + b.genişlik)) Λ (f.y ≥ b.y) Λ (f.y &#x3C; (b.y + b.yükseklik)) <br>\n<strong>B:</strong> f.SolTuşuTıklandıMı <br></p>\n<blockquote>\n<p>Bugün neredeyse bütün tıklanma kontrolleri ve basit çarpışma kontrolü A ve B formülünün 1 veya 0 sonuçlanmasına göre kontrol edilmekte.</p>\n</blockquote>\n<p>Koşullarımızı detaylandırdıysak artık <strong>C = A Λ B</strong> <em>(veya A.B, biz genelde yaygın olan nokta (.) gösterimini kullanacağız)</em> bize butonun tıklanıp tıklanmadığını veren mantıksal formül oldu.</p>\n<h3>Birkaç basit sözlü ifadeyi mantıksal ifadeye çevirelim:</h3>\n<p>“A butonuna basılır ve B butonuna basılmaz ise C koşulu doğrudur”:</p>\n<blockquote>\n<p>C = A.B’</p>\n</blockquote>\n<p>“T düğmesi veya J düğmesine basılırsa K kliması açılsın”:</p>\n<blockquote>\n<p>K = T+J</p>\n</blockquote>\n<p>“O ve P tuşları basılmıyor **veya **O ve P tuşları aynı anda basılıyor ise U koşulu doğrudur”:</p>\n<blockquote>\n<p>U = (O’.P’) + (O.P)</p>\n</blockquote>\n<p>U = (O+P)’ + (O.P) şeklinde de yazılabilir. — “O veya P basılıyor değilse”</p>\n<p>Gördüğünüz gibi mantıksal ifadeler oluşturmak gayet kolay :)</p>\n<p>Mantıksal ifadeler hakkında daha fazla bilgiyi ve bazı matematiksel kuramları <em>(De Morgan Kuralları gibi)</em> pek çok internet sayfasında ve YouTube kanallarında bulabilirsiniz.</p>\n<h3>Mantık güzel, peki “Kapıları” nedir?</h3>\n<p><strong>Mantık Kapıları</strong> yukarıda sadece kağıt üzerinde ifade ettiğimiz mantıksal ifadeleri gerçek hayatta donanımsal olarak gerçekleştirmemize olanak sağlayan elektronik devre elemanlarıdır.</p>\n<blockquote>\n<p>Örneğin bir kumandada iki butona birden basıldığında bir cihazın çalışması</p>\n</blockquote>\n<p>Elektronikte\n“VE kapısı” dediğimiz şey Mantıktaki <strong>Ve (Λ)</strong>’nin,\n“VEYA” kapısı da <strong>Veya (V)</strong>’nın karşılığıdır.</p>\n<p><img src=\"static/img/ram/mantik-kapilari-hepsi.gif\" alt=\"Mantık kapılarının tümü\"></p>\n<p>Çalışma şekilleri yukarıdaki gibi verilmiş kapıların matematiksel olarak da karşılıklarını bilmek isteriz. Çünkü her zaman ezbere iş yapamayız veya ilgilenen ifade git gide karmaşıklaşıp büyüyebilir.</p>\n<p>Bu yüzden <strong>Doğruluk Tablolarını</strong> kullanırız. Doğruluk tabloları bir <strong>elemanın</strong> veya bir <strong>ifadenin</strong> tüm giriş kombinasyonları için çıkışlarını gösterdiğimiz bir tablodan ibaret. Çok basit fakat çok yararlı.</p>\n<h3>Birkaç Doğruluk Tablosu örneği:</h3>\n<p>Mesela A ve B girişlerimiz olsun, bunlardan <strong>sadece bir tanesi</strong> 1 olduğu zaman doğru olan sonuçla Doğruluk Tablosunu çizelim:</p>\n<p><img src=\"static/img/ram/xor-tablo.png\" alt=\"XOR Doğruluk Tablosu\"></p>\n<p>Bu gördüğümüz tablo aslında <strong>Özel VEYA</strong>(XOR veya EXOR) kapısının doğruluk tablosudur.</p>\n<p><strong>Özel VEYA</strong> da örnek ile aynı şeyi gerçekleştirmekte. (yani Farklıysa 1, aynısya 0)</p>\n<p>Elinizdeki duruma göre istediğiniz girişlerde istediğiniz şekilde sonuçlar çıkaran doğruluk tabloları çizebilirsiniz.</p>\n<blockquote>\n<p>Matematiksel olarak ifade edilebilen her doğruluk tablosu gerçeğe dönüştürülebilir.\nBu yüzden bir olayı <strong>doğruluk tablosuna</strong> dökebilmek, onu elektronik ortama aktarabilmek demektir.</p>\n</blockquote>\n<p>Mesela yine A ve B girişlerimiz olsun, fakat şimdi sadece A da B de 1 olduğu zaman sonuç doğru olsun:</p>\n<p><img src=\"static/img/ram/and-tablo.png\" alt=\"AND Doğruluk Tablosu\"></p>\n<p>Bu gördüğümüz tablo da aslında <strong>VE</strong> (AND) kapısının doğruluk tablosudur.</p>\n<p><strong>VE</strong> kapısı sadece iki giriş de <strong>1</strong> olduğu, yani elektrik geldiği zaman 1 olur, sonuç olarak o da elektrik verir.</p>\n<p>Doğruluk Tabloları küçük boyutlarda işimize yarıyor, fakat örneğin elimizde 5 tane durum var ise ne yapacağız? <em>(Bunun için 32 satırlık bir doğruluk tablosu yapmamız gerekir :))</em></p>\n<p><strong>Böyle durumlarda Karnaugh Haritaları kullanırız.</strong> Karnaugh Haritaları doğruluk tablosunun iki boyutlu düzleme dökülmüş halidir. Yani durumlar tek bir sütun kaplamak yerine satır ve sütunlara dağıtılırlar.</p>\n<p><img src=\"static/img/ram/karna1.png\" alt=\"4 Duruma sahip basit bir karnaugh haritası. (Boş alanlar 0)\"><br>\n<em>4 Duruma sahip basit bir karnaugh haritası. (Boş alanlar 0)</em></p>\n<p>Karnaugh Haritalarının bir diğer bir avantajı ise işlemi sadeleştirmenin çok kolay yapılabilmesidir.</p>\n<p>Örneğin biz A ve B’nin sadece 11'de 1 ürettiğini gördüğümüz için kolayca bu tablo tek bir <strong>VE</strong> kapısıyla gerçeklenebilir diyebildik.</p>\n<p><strong>Fakat durum sayısı arttıkça birden fazla kapı gerekebilir. Ve bu durum işlem sadeleştirilmesi yapılmaz ise gereksiz kapı kullanımıyla sonuçlanabilir.</strong></p>\n<p><strong>Bu da daha fazla Masraf+ Boyut + Enerji harcaması demek.</strong></p>\n<blockquote>\n<p>İleride 1 bit veri saklama için kullanacağımız VE-VEYA Mandalı devresi Karnaugh Haritası ile yapılan sadeleştirme ile sadece 3 tane kapıdan oluşmakta.)</p>\n</blockquote>\n<p><strong>Mantık Kapıları</strong> ve <strong>Doğruluk Tablosu</strong>’nu hallettiğimize göre bu yazıyı bitirebiliriz.</p>\n<p>Bir sonraki yazımız olan <a href=\"0-dan-ram-3-karnaugh-haritalari\"><strong>0 → RAM | 3) Karnaugh Haritaları</strong></a>'nda görüşmek üzere!</p>","id":"a43c7591-3fab-5cce-bce4-23d319b757e7","frontmatter":{"date":"Mart 03, 2020","description":"İleride sıkça kullanacağımız mantık kapılarına bir el atalım.","image":"static/img/ram/kapak-ram2.png","path":"/0-dan-ram-2-mantik-kapilari","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 2) Mantık Kapıları"}},"next":{"excerpt":"Merhabalar! Bu yazımızda RAM’imizin içindeki belirli adreslere erişmek için devremizde kullanacağımız Kod Çözücüleri ve Kodlayıcıları ele alacağız. Kod Çözücüler ne işe yarar? Bir Kod Çözücü kısaca…","html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizin içindeki belirli adreslere erişmek için devremizde kullanacağımız <strong>Kod Çözücüleri</strong> ve <strong>Kodlayıcıları</strong> ele alacağız.</p>\n<h2>Kod Çözücüler ne işe yarar?</h2>\n<p>Bir Kod Çözücü kısaca: <strong>seçim elemanıdır.</strong></p>\n<p>Girişlerine ikilik tabanda verilen girdiye göre sadece bir çıkışını aktif eder. Örneğin <strong>2 girişli</strong> ve <strong>4 çıkışlı</strong> (2x4) bir Kod Çözücü aşağıdaki gibi çalışır:</p>\n<blockquote>\n<p>00 -> <strong>0</strong></p>\n<p>01 -> <strong>1</strong></p>\n<p>10 -> <strong>2</strong></p>\n<p>11 -> <strong>3</strong></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*XHlRexbJWrW9BobgAUxDtQ.gif\" alt=\"2 Giriş, 4 Çıkışlı bir kod çözücünün çalışma şekli.\"></p>\n<p><em>2 Giriş, 4 Çıkışlı bir kod çözücünün çalışma şekli.</em></p>\n<p>Gördüğünüz gibi burada decoderin(kod çözücünün) iç devre tasarımı yok, bize sadece giriş ve çıkış uçları olan bir devre elemanı olarak verilmiş.</p>\n<p>Bu olaya <strong>abstraction</strong> yani <strong>soyutlama</strong> denir.</p>\n<p>Çoğu zaman yaptığımız ve bir işlevi gerçekleştirebilen küçük devreleri her seferinde tekrardan çizmeyiz. Bir kere çizdikten sonra onları bir eleman haline getirip sonra çoğaltarak istediğimiz kadar kullanırız. <em>(Bu düstur yazılımda da sıkça kullanılmaktadır)</em></p>\n<p>Fakat biz yine de kendi decoderimizi de yapmayı öğrenebilmek adına içine bir göz atalım :)</p>\n<p><em>Aslında gayet basit bir iç devresi var.</em></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*N3XCDp5dOmWpUfCdqYm0Hg.gif\" alt=\"2x4 Kod Çözücünün içi.\"><em>2x4 Kod Çözücünün içi.</em></p>\n<p>Siz de kolayca çıkışlarımızın mantıksal durumlarını yazarak devreyi rahatlıkla bulabilirdiniz. Nitekim biz de öyle yaptık:</p>\n<blockquote>\n<p>Y0= X1’.X0’ (00)</p>\n<p>Y1= X1’.X0 (01)</p>\n<p>Y2= X1.X0’ (10)</p>\n<p>Y3= X1.X0 (11)</p>\n</blockquote>\n<h3>“İyi güzel de, bu RAM yaparken ne işimize yarayacak?”</h3>\n<p>Eğer yazılım ile uğraşıyorsanız, özellikle C/C++ gibi adreslemelerin <em>(pointer)</em> bolca kullanıldığı dillerde tanımladığınız <strong>değişkenlerin</strong> bir <strong>adresi</strong> olduğunu fark etmişsinizdir.</p>\n<p>Bu adres genelde <strong>0x123456</strong> şeklinde onaltılık tabanda gösterilen bir sayı olur ve değişkeninizdeki <strong>verinin</strong> RAMinizde 0x123456 nolu bellek hücresinde tutulduğunu belirtir.</p>\n<h3>Mesela:</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*ZUdJocmCbepWUyJnPSk-5w.png\" alt=\"a isminde bir değişkenin RAM’deki bir hücrede saklanması.\"></p>\n<p><em>a isminde bir değişkenin RAM’deki bir hücrede saklanması.</em></p>\n<h3>İşte tam burada kod çözücüler devreye giriyor.</h3>\n<p>Bilgisayarda tüm işlemlerimiz İkilik (Binary) sistemde, yani 0 veya 1.</p>\n<p>0x100002 nolu hücreye erişebilmek için <strong>örneğin 4GB</strong>’lik bir RAM’de <strong>4,294,967,296</strong> tane hücreden <strong>sadece 1 tanesini</strong> seçip okumamız/yazmamız gerek ve bunu ikilik sistemde çalışan işlemcimizden aldığımız bitler ile yapabilmeliyiz.</p>\n<p>Kod Çözücüler ise seçim elemanlarıydı ve tam da aradığımız gibi; girişlerine ikilik sistemden bir sayı alıp, çıkışlarından sadece o sayıya karşılık gelen çıkışı aktif hale getiriyordu.</p>\n<p>Bu şekilde eğer bir Kod çözücüye <strong>2³² = 4,294,967,296</strong> hesabıyla <strong>32 giriş</strong> ve <strong>4,294,967,296</strong> farklı çıkış verirsek tüm hücrelere rahatlıkla erişebiliriz değil mi?</p>\n<h3>Aslında pek de sayılmaz :)</h3>\n<p>4,294,967,296 tane kabloyu teker teker bir hücreye bağlamak hem kablo, hem alan hem de işlem israfı olacaktır. Bu yüzden tek boyutlu olarak düşündüğümüz hücreleri adresleme işlemini iki boyutlu düşünmeliyiz. Yani 1 boyutlu bir dizi değil de, 2 boyutlu bir Matris olarak hücrelerimizi tutmalıyız.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*-KvuViSro2avKO3wtKrXww.gif\" alt=\"2 boyutlu matris kullanarak daha az kablo kullanımını sağlamak.\"><em>2 boyutlu matris kullanarak daha az kablo kullanımını sağlamak.</em></p>\n<p>4GB’lik bir RAM için ise 2³² şeklinde tek bir decoder yerine, 2⁸’lik 4 tane decoder kullanılabilir. Böylece kablo sayısı 4,294,967,296'dan 128'e düşüyor. Bu da bize <strong>33 milyon kat</strong> daha az kablo kullanımı ile muazzam bir tasarruf sağlıyor.</p>\n<h2>Kod çözücüler de tamam!</h2>\n<p>Artık RAM yapabilmek için temel bileşenlerin çoğunun çalışma şeklini biliyoruz.</p>\n<p>Şimdi geriye bu bileşenleri kullanarak bir RAM tasarlamak kaldı.</p>\n<p>Bir sonraki yazımız olan <strong><a href=\"0-dan-ram-5-ram-hucresi\">0 → RAM | 5) RAM Hücresi</a></strong>'inde görüşmek üzere!</p>","id":"46b74bd1-d671-5a63-8562-d70a94ae6ec4","frontmatter":{"date":"Mart 05, 2020","description":"Temel RAM bileşenlerimizin sonuncusu \"Kod Çözücüler\"","image":"static/img/ram/kapak-ram4.png","path":"/0-dan-ram-4-kod-cozuculer","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 4) Kod Çözücüler"}}}}}