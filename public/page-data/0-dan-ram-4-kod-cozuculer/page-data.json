{"componentChunkName":"component---src-templates-blog-post-js","path":"/0-dan-ram-4-kod-cozuculer","result":{"data":{"markdownRemark":{"html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizin içindeki belirli adreslere erişmek için devremizde kullanacağımız <strong>Kod Çözücüleri</strong> ve <strong>Kodlayıcıları</strong> ele alacağız.</p>\n<h2>Kod Çözücüler ne işe yarar?</h2>\n<p>Bir Kod Çözücü kısaca: <strong>seçim elemanıdır.</strong></p>\n<p>Girişlerine ikilik tabanda verilen girdiye göre sadece bir çıkışını aktif eder. Örneğin <strong>2 girişli</strong> ve <strong>4 çıkışlı</strong> (2x4) bir Kod Çözücü aşağıdaki gibi çalışır:</p>\n<blockquote>\n<p>00 -> <strong>0</strong></p>\n<p>01 -> <strong>1</strong></p>\n<p>10 -> <strong>2</strong></p>\n<p>11 -> <strong>3</strong></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*XHlRexbJWrW9BobgAUxDtQ.gif\" alt=\"2 Giriş, 4 Çıkışlı bir kod çözücünün çalışma şekli.\"></p>\n<p><em>2 Giriş, 4 Çıkışlı bir kod çözücünün çalışma şekli.</em></p>\n<p>Gördüğünüz gibi burada decoderin(kod çözücünün) iç devre tasarımı yok, bize sadece giriş ve çıkış uçları olan bir devre elemanı olarak verilmiş.</p>\n<p>Bu olaya <strong>abstraction</strong> yani <strong>soyutlama</strong> denir.</p>\n<p>Çoğu zaman yaptığımız ve bir işlevi gerçekleştirebilen küçük devreleri her seferinde tekrardan çizmeyiz. Bir kere çizdikten sonra onları bir eleman haline getirip sonra çoğaltarak istediğimiz kadar kullanırız. <em>(Bu düstur yazılımda da sıkça kullanılmaktadır)</em></p>\n<p>Fakat biz yine de kendi decoderimizi de yapmayı öğrenebilmek adına içine bir göz atalım :)</p>\n<p><em>Aslında gayet basit bir iç devresi var.</em></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*N3XCDp5dOmWpUfCdqYm0Hg.gif\" alt=\"2x4 Kod Çözücünün içi.\"><em>2x4 Kod Çözücünün içi.</em></p>\n<p>Siz de kolayca çıkışlarımızın mantıksal durumlarını yazarak devreyi rahatlıkla bulabilirdiniz. Nitekim biz de öyle yaptık:</p>\n<blockquote>\n<p>Y0= X1’.X0’ (00)</p>\n<p>Y1= X1’.X0 (01)</p>\n<p>Y2= X1.X0’ (10)</p>\n<p>Y3= X1.X0 (11)</p>\n</blockquote>\n<h3>“İyi güzel de, bu RAM yaparken ne işimize yarayacak?”</h3>\n<p>Eğer yazılım ile uğraşıyorsanız, özellikle C/C++ gibi adreslemelerin <em>(pointer)</em> bolca kullanıldığı dillerde tanımladığınız <strong>değişkenlerin</strong> bir <strong>adresi</strong> olduğunu fark etmişsinizdir.</p>\n<p>Bu adres genelde <strong>0x123456</strong> şeklinde onaltılık tabanda gösterilen bir sayı olur ve değişkeninizdeki <strong>verinin</strong> RAMinizde 0x123456 nolu bellek hücresinde tutulduğunu belirtir.</p>\n<h3>Mesela:</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*ZUdJocmCbepWUyJnPSk-5w.png\" alt=\"a isminde bir değişkenin RAM’deki bir hücrede saklanması.\"></p>\n<p><em>a isminde bir değişkenin RAM’deki bir hücrede saklanması.</em></p>\n<h3>İşte tam burada kod çözücüler devreye giriyor.</h3>\n<p>Bilgisayarda tüm işlemlerimiz İkilik (Binary) sistemde, yani 0 veya 1.</p>\n<p>0x100002 nolu hücreye erişebilmek için <strong>örneğin 4GB</strong>’lik bir RAM’de <strong>4,294,967,296</strong> tane hücreden <strong>sadece 1 tanesini</strong> seçip okumamız/yazmamız gerek ve bunu ikilik sistemde çalışan işlemcimizden aldığımız bitler ile yapabilmeliyiz.</p>\n<p>Kod Çözücüler ise seçim elemanlarıydı ve tam da aradığımız gibi; girişlerine ikilik sistemden bir sayı alıp, çıkışlarından sadece o sayıya karşılık gelen çıkışı aktif hale getiriyordu.</p>\n<p>Bu şekilde eğer bir Kod çözücüye <strong>2³² = 4,294,967,296</strong> hesabıyla <strong>32 giriş</strong> ve <strong>4,294,967,296</strong> farklı çıkış verirsek tüm hücrelere rahatlıkla erişebiliriz değil mi?</p>\n<h3>Aslında pek de sayılmaz :)</h3>\n<p>4,294,967,296 tane kabloyu teker teker bir hücreye bağlamak hem kablo, hem alan hem de işlem israfı olacaktır. Bu yüzden tek boyutlu olarak düşündüğümüz hücreleri adresleme işlemini iki boyutlu düşünmeliyiz. Yani 1 boyutlu bir dizi değil de, 2 boyutlu bir Matris olarak hücrelerimizi tutmalıyız.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*-KvuViSro2avKO3wtKrXww.gif\" alt=\"2 boyutlu matris kullanarak daha az kablo kullanımını sağlamak.\"><em>2 boyutlu matris kullanarak daha az kablo kullanımını sağlamak.</em></p>\n<p>4GB’lik bir RAM için ise 2³² şeklinde tek bir decoder yerine, 2⁸’lik 4 tane decoder kullanılabilir. Böylece kablo sayısı 4,294,967,296'dan 128'e düşüyor. Bu da bize <strong>33 milyon kat</strong> daha az kablo kullanımı ile muazzam bir tasarruf sağlıyor.</p>\n<h2>Kod çözücüler de tamam!</h2>\n<p>Artık RAM yapabilmek için temel bileşenlerin çoğunun çalışma şeklini biliyoruz.</p>\n<p>Şimdi geriye bu bileşenleri kullanarak bir RAM tasarlamak kaldı.</p>\n<p>Bir sonraki yazımız olan <strong><a href=\"0-dan-ram-5-ram-hucresi\">0 → RAM | 5) RAM Hücresi</a></strong>'inde görüşmek üzere!</p>","frontmatter":{"date":"Mart 05, 2020","image":"static/img/ram/kapak-ram4.png","path":"/0-dan-ram-4-kod-cozuculer","tags":["RAM"],"title":"0 → RAM | 4) Kod Çözücüler"}}},"pageContext":{"slug":"/0-dan-ram-4-kod-cozuculer","previous":{"excerpt":"Merhabalar! Önceki derste Mantık Kapılarına ve Doğruluk Tablolarına giriş yapmıştık. Doğruluk Tabloları güzeldi fakat bir eksiği vardı ki; kapı sayısı arttıkça Doğruluk Tablolarının çekilemez…","html":"<h2>Merhabalar!</h2>\n<p>Önceki derste <strong>Mantık Kapıları</strong>na ve <strong>Doğruluk Tabloları</strong>na giriş yapmıştık. Doğruluk Tabloları güzeldi fakat bir eksiği vardı ki; kapı sayısı arttıkça <strong>Doğruluk Tabloları</strong>nın çekilemez uzunluklara ulaşması ve sadeleştirme işlemlerinin biraz daha zor görülmesiydi.</p>\n<p>İşte bu sıkıntıları çekmemek için Maurice Karnaugh ve Edward Veitch’in güzel bir çalışması olan Karnaugh (Karnaugh-Veitch) Haritalarını kullanacağız.</p>\n<h2>Karnaugh Haritaları (Karnaugh-Veitch Maps)</h2>\n<p>Karnaugh Haritaları basitçe doğruluk tablosunun aşağıya doğru uzayan hali yerine <strong>iki boyutlu bir tablo</strong> haline getirilmesinden ibaret. <strong>Fakat bize sağladığı kolaylıklar çok fazla. :)</strong></p>\n<h3>Bir örnek yapalım:</h3>\n<p>Örneğimiz bir toplayıcı devresi olsun. Devremizde <strong>Bit-1</strong>, <strong>Bit-2</strong> butonları (girişleri) ve <strong>SONUÇ</strong> ve <strong>ELDE</strong> çıkışları (buralara LED bağlayabiliriz) olsun.</p>\n<p>Gireceğimiz iki biti toplayan ve eğer <strong>elde <em>(carry)</em></strong> değeri elde edersek <strong>ELDE</strong> çıkışını 1 yapan <em>(amma çok elde kelimesi geçti… :))</em>, toplama sounucunu da <strong>SONUÇ</strong> çıkışına veren bir devre yapalım. Bu devrenin doğruluk tablosunu çizersek şöyle bir sonuç elde ederiz:</p>\n<p><img src=\"static/img/ram/half-adder-tablosu.png\" alt=\"Yarım Toplayıcı(Half-Adder) Doğruluk Tablosu\"><em>Yarım Toplayıcı(Half-Adder) Doğruluk Tablosu</em></p>\n<p><strong>“Sonuç”</strong> çıkışı görebileceğimiz üzere bir <strong>Özel VEYA</strong> (XOR) kapısı ile gerçeklenebilir, çünkü sadece tet bir bit <strong>1</strong> olduğu zaman çıkış <strong>1</strong>.</p>\n<blockquote>\n<p>XOR: ⊕</p>\n<p>XNOR: ⊙</p>\n</blockquote>\n<p><strong>“Elde”</strong> çıkışımız ise sadece iki bit de 1 olduğu zaman 1 oluyor. O halde Elde çıkışı bir <strong>VE</strong> kapısı ile gerçeklenebilir. Bu durumda devremizin Sonuç çıkışının mantık kapılarıyla formülünü çıkarmak istersek:</p>\n<blockquote>\n<p><strong>Sonuç</strong> = <strong>b1 ⊕ b2</strong></p>\n<p><strong>Elde</strong> = <strong>b1 . b2</strong></p>\n</blockquote>\n<p>Tebrikler, bir <strong>Yarım Toplayıcı</strong> yaptınız :)</p>\n<h2>İyi de neden “Yarım” oldu ki?</h2>\n<p><img src=\"static/img/ram/half-adder.gif\" alt=\"Yarım Toplayıcı (Half-Adder) devresi\"></p>\n<p><em>Yarım Toplayıcı (Half-Adder) devresi</em></p>\n<p>Bu devreye “<strong>Yarım Toplayıcı</strong>” denilmesinin sebebi işleme bir önceki sonucun eldesini katmıyor olması. Devre çıkış olarak ELDE veriyor, fakat giriş olarak başka bir toplayıcıdan gelen ELDE’yi <strong>dikkate almıyor</strong>.</p>\n<p>O halde <strong>girişlerimize</strong> de bir <strong>ELDE</strong> ekleyip <strong>TAM</strong> bir toplayıcı yapalım :)</p>\n<p><strong>Tam Toplayıcının doğruluk tablosunu çizersek</strong>:</p>\n<p><img src=\"static/img/ram/full-adder-tablosu.png\" alt=\"b1, b2 ve Elde girişine sahip tam toplayıcının doğruluk tablosu\"></p>\n<p><em>b1, b2 ve Elde girişine sahip tam toplayıcının doğruluk tablosu</em></p>\n<p><em>(eveeet işler biraz karıştı değil mi :))</em></p>\n<p><strong>Sonuç</strong> ve <strong>Elde</strong> çıkışlarımızda 1'ler biraz karışık şekilde dağılmış. Örneğin yarım toplayıcıdaki gibi <strong>“Sonuç”</strong> çıkışı için hangi kapı veya kapılar gerekir kestiremiyoruz.</p>\n<h3>O zaman Karnaugh!</h3>\n<p><img src=\"static/img/ram/full-adder-karna.gif\" alt=\"Sonuç ve Elde çıkışlarımızı elde etmek için kullandığımız Karnaugh Haritaları\"></p>\n<p><em>Sonuç ve Elde çıkışlarımızı elde etmek için kullandığımız Karnaugh Haritaları</em></p>\n<p><strong>Elde</strong> ve <strong>Sonuç</strong> çıkışları için; <strong>b1</strong>, <strong>b2</strong> ve <strong>E</strong> girişlerine göre <strong>Karnaugh Haritası</strong> çizersek yukarıdaki gibi iki tane harita elde ederiz.</p>\n<p><em>(Karnaugh’da her çıkış için ayrı tablo çizilir.)</em></p>\n<p>Önemli NOT:</p>\n<blockquote>\n<p>Karnaugh’da sütun veya satırlar sırayla <strong>00–01–10–11</strong> şeklinde <strong>DEĞİL</strong>, <strong>GrayCode</strong> dizilimi olan ve bir sonraki durumla arasında sadece 1 bit fark olan <strong>00–01–11–10</strong> formatında yazılır.\n<strong>GrayCode</strong> formatına göre eğer bir satırda üç tane değişkenimiz olsaydı: <strong>000–001–011–010–110–111–101–100</strong> şeklinde yazacaktık. (iki durum arası sadece 1 bit farklı.)</p>\n</blockquote>\n<h3>Haritanın üzerine niye kutular çizdik ki?</h3>\n<p>Karnaugh Haritalarını özel kılan şey de bu.</p>\n<p>Doğruluk Tablosunda göremediğimiz “1'ler arasındaki ilişkiyi” burada gözle görebiliyoruz, bu da bize <strong>1'leri gruplandırıp</strong>, aynı sonucu verecek devre için <strong>fazladan</strong> kullanacağımız elemanlardan kurtulabilmemizi sağlıyor.</p>\n<p>Mesela <strong>ELDE</strong>’nin haritasındaki mavi kutuyu düşünelim. E b1 b2 sırasıyla yazarsam 101 ve 111 aynı sonucu veriyor <em>(yani 1)</em>. Yani ortadaki değerin (b1) 0 veya 1 olması sonucu etkilemiyor. Bu yüzden b1 girişini devreye katmayıp, <strong>E</strong> ve <strong>b2</strong>'yi bir <strong>VE</strong> kapısına bağlıyoruz.</p>\n<h3>Peki neyi sadeleştirdi bu?</h3>\n<p>Eğer b1'i de kaale alsaydık aynı sonucu elde edebilen şöyle bir devre kurabilirdik:</p>\n<blockquote>\n<p>ELDE = E.<strong>(b1.b2 + b1’.b2)</strong> + …</p>\n</blockquote>\n<p>Halbuki Karnaugh sayesinde yukarıda 5 kapı kullanırken, sadeleştirdiğimiz sonuçta 2 kapı kullanıyoruz:</p>\n<blockquote>\n<p>ELDE = <strong>E.b2</strong> + …</p>\n</blockquote>\n<h2>“ELDE” tablosundaki yan yana üç tane 1'i neden bir grup yapıp daha fazla sadeleştirme yapmadık?</h2>\n<p>Karnaugh Haritalarıda gruplama yaparken elbette belirli kurallarımız var, gruplama yaparken bu kurallara göre yapıyoruz:</p>\n<blockquote>\n<p>*Sadece <strong>2ᶰ katları</strong> kadar 1'ler <strong>gruplanabilir:*</strong></p>\n</blockquote>\n<p><img src=\"static/img/ram/karna-kural1.gif\" alt=\"*Sadece **2ᶰ katları** kadar 1&#x27;ler **gruplanabilir**.*\"></p>\n<blockquote>\n<p>*Gruplamaya önce <strong>en az komşuya sahip</strong> 1'lerden başla:*</p>\n</blockquote>\n<p><img src=\"static/img/ram/karna-kural2.gif\" alt=\"*Gruplamaya önce **en az komşuya sahip** 1&#x27;lerden başla.*\"></p>\n<p>Çok da değil aslında 2 tane mühim kuralımız varmış :)</p>\n<h3>Konumuza geri dönelim: “Tam Toplayıcı”</h3>\n<p>Karnaugh haritasını çizdiğimiz çıkışların denklemlerini yazalım:</p>\n<p><strong>SONUÇ</strong> = E.b1'.b2' + E’.b1'.b2 + E.b1.b2 + E’.b1.b2'\n<strong>ELDE</strong> = E.b2 + E.b1 + b1.b2</p>\n<p>Karnaugh’daki grupları yazdığımızda elde ettiğimiz sonuçlar böyle, fakat yine de tam istediğimiz sadelikte değil. Mantık ilminin matematiksel özelliklerini kullanarak buradan da sadeleştirmeler yapabiliriz.</p>\n<p><strong>SONUÇ</strong> = E.(b1'.b2' + b1.b2) + E’.(b1'.b2 + b1.b2')</p>\n<p>Dikkatli bakarsak 1. parantez içinin XNOR, (00 veya 11 koşulu)</p>\n<ol start=\"2\">\n<li>parantez içinin ise XOR (01 veya 10 koşulu) olduğunu görebiliriz.</li>\n</ol>\n<p>En sade haliyle **SONUÇ **çıkışımızın formülü şöyle olacaktır:</p>\n<p><strong>SONUÇ</strong> = E.(b1 ⊙ b2) + E’.(b1 ⊕ b2)\n<strong>SONUÇ</strong> = E.<strong>(b1 ⊕ b2)’</strong> + E’.(b1 ⊕ b2)</p>\n<blockquote>\n<p>A.B’ + A’.B = A⊕B</p>\n</blockquote>\n<p><strong>SONUÇ</strong> = E ⊕ b1 ⊕ b2\n(2 XOR)</p>\n<p>ELDE çıkışında ise E’leri paranteze alabiliriz:</p>\n<p><strong>ELDE</strong> = E.(b1⊕b2) + b1.b2\n<em>(2 VE, 1 XOR (yukarıdan), 1 VEYA)</em></p>\n<p>Devremizi gerçekleyelim:</p>\n<p><img src=\"static/img/ram/full-adder.gif\"></p>\n<h3>Karnaugh’yı da hallettik!</h3>\n<p>Temel derslerden en önemlisi olarak gördüğüm Karnaugh Haritalarını da bu yazıda bitirelim. <strong>0'dan RAM yapma hedefimize adım adım ilerliyoruz.</strong></p>\n<p>Bir sonraki yazımız olan <a href=\"0-dan-ram-4-kod-cozuculer\"><strong>0 → RAM | 4) Kod çözücüler</strong></a>'de görüşmek üzere.</p>","id":"ebb3cad0-2c8b-595c-99a5-acb67e541238","frontmatter":{"date":"Mart 04, 2020","description":"Mantık devreleri inşa etmek için mühim yöntemlerden birisi \"Karnaugh Haritaları\"","image":"static/img/ram/kapak-ram3.png","path":"/0-dan-ram-3-karnaugh-haritalari","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 3) Karnaugh Haritaları"}},"next":{"excerpt":"Merhabalar! Bu yazımızda RAM’imizin iç devresini tasarlamaya başlayacağız. Atacağım devre dosyaları Logisim programından olacak. Tamamen sıfırdan kendi RAM’inizi inşa edip, simüle edip test…","html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizin iç devresini tasarlamaya başlayacağız. Atacağım devre dosyaları <a href=\"https://sourceforge.net/projects/circuit/\"><strong>Logisim</strong></a> programından olacak. Tamamen sıfırdan kendi RAM’inizi inşa edip, simüle edip test edebileceksiniz :)</p>\n<h2>RAM’imiz nasıl bir şey olacak?</h2>\n<p>RAM’imizin iç devresini tasarlamadan önce içi hazır bir eleman olarak düşünüp sadece giriş ve çıkışlarını tasarlayalım. <strong>Yani genel hatlarını belli edelim.</strong></p>\n<p>RAM’imiz <strong>2⁸x8</strong> boyutlarında olacak. Buradaki ilk değer RAM’in içindeki <strong>hücre</strong> sayısıdır. Yani 2⁸ tane <strong>çekmeceden</strong> oluşan bir dolap gibi düşünülebilir.</p>\n<p>İkinci değer (8) ise her çekmecenin içinde saklanan bit sayısıdır.</p>\n<p>Yani 2⁸=256 tane hücremiz var, her hücrede de 8 bit saklıyoruz.</p>\n<blockquote>\n<p>Dolayısıyla RAM’imiz <strong>2048</strong> adet <strong>0</strong> veya <strong>1</strong> saklıyor\n<strong>8 bit = 1 byte</strong> olduğundan <strong>256 Byte</strong>’lık bir RAM’imiz olacak.</p>\n</blockquote>\n<p>Eğer 1GB’lık bir RAM yapmak isteseydik:</p>\n<p><strong>1GB için 2³⁰x8</strong><br>\n<strong>2GB için 2³¹x8</strong><br>\n<strong>4GB için 2³²x8</strong>\nbir RAM tasarlayacaktık.</p>\n<p>32 bit işlemcilerin olduğu sistemlere 4GB’dan fazla RAM <strong>takılamamasının</strong> sebebi en fazla <strong>2 üzeri 32'ye</strong> kadar adres tutabilmesidir. Yani 2³²’den ekstra 1 tanecik fazla da olsa hücreyi adresleyemez, veriyi saklayamaz, tanımlayamaz, saklaması için 33. yeni bir bite ihtiyacı var.</p>\n<p>64 bit sistemler ise 2⁶⁴ yani <strong>“18 446 744 073 709 551 616 Byte”</strong> hafızaya sahip olacak kadar adresleme yapabilir, bu da yaklaşık <strong>“17 179 869 184 GB”</strong> yapıyor :) <em>(4GB’ye göre gerçekten yüksek bir rakam)</em></p>\n<blockquote>\n<p>Yani 64 bit işlemciye sahip bir bilgisayarınız varsa 17 Milyar GB RAM’e kadar yükseltme yapabilirsiniz (tabi gerçek hayatta adres tutmak için 64 bitin hepsi ayrılmaz :))</p>\n</blockquote>\n<h3>RAM Çipimizin Genel Tasarımı</h3>\n<p><img src=\"static/img/ram/ram-chip.png\" alt=\"RAM Çipimizin Genel Tasarımı.\"></p>\n<p><em>RAM Çipimizin Genel Tasarımı.</em></p>\n<p><strong>Y:</strong> Yüksek Değerlikli Bit (<strong>2⁷</strong>)<br>\n<strong>D:</strong> Düşük Değerlikli Bit (<strong>2⁰</strong>)<br>\n<strong>CS (Chip Select):</strong> RAM çipimizi aktif eden giriş.<br>\n<strong>R’/W:</strong> Okuma yapmak için <strong>0 (R’)</strong> Yazma yapmak için <strong>1 (W)</strong> değeri verilmesi gereken girişimiz.</p>\n<p>--</p>\n<p>Çipimiz tamam, peki işlemci ile veri alışverişini nasıl sağlayacak? Çıkışları direk işlemciye mi bağlayacağız? Eğer öyle ise her yaptığımız eleman için işlemcide ayrı ayrı çıkışların mı olması gerek?</p>\n<h3>Veri Aktarım Yöntemi</h3>\n<p>Normal şartlarda iki şekilde bir çipi başka bir çip ile haberleştirebilirsiniz:</p>\n<p><strong>1.</strong> Direkt olarak birinin <strong>çıkışlarını</strong> diğerinin <strong>girişlerine</strong> bağlarsınız</p>\n<p><strong>2.</strong> İki veya daha fazla çipi ortak bir tane veri yoluna bağlayıp, <strong>Çip Seçim</strong> girişleri ile sadece konuşturmak istediğiniz çipleri aktif ederek veri aktarımını sağlarsınız.</p>\n<p><em>(Örneğin SSD’den veri okuyacağım, o zaman SSD’yi aktif edip diğerlerini pasif halde tutarım. Veya RAM’den veri okumak istiyorum, diğerlerini pasif hale getirip bu sefer de sadece RAM’i aktif ederim)</em></p>\n<p><img src=\"static/img/ram/common-data-bus.gif\" alt=\"Ortak veri yolu kullanan çiplerin Chip Select girişi kullanılarak veri yoluna bağlanması.\">\n<br><em>Ortak veri yolu kullanan çiplerin Chip Select girişi kullanılarak veri yoluna bağlanması.</em></p>\n<h2>Gelelim artık RAM Hücresine!</h2>\n<p>Güzel bir söz var:</p>\n<blockquote>\n<p><strong>\"Baharı icad etmeyen, bir elmayı icad edemez. Zira o elma, o tezgâhta dokunuyor. Bir elmayı icad eden, bir baharı icad edebilir…\"</strong></p>\n</blockquote>\n<p>Bunun RAM ile alakası ise;</p>\n<blockquote>\n<p>Milyarlarca biti saklayabilmek için önce 1 biti saklayabilmek gerek,\n1 biti saklayamayan milyarları saklayamaz.\nMilyarları saklayabilen 1 biti saklayabilendir.</p>\n</blockquote>\n<p>Yani önce <strong>tek bir biti saklayabilen</strong> bir <strong>“RAM Hücresi”</strong> yapıp sonra bunu istediğimiz sayıda kopyalarak istediğimiz boyutta RAM elde edeceğiz.</p>\n<p><img src=\"static/img/ram/ram-cell.gif\" alt=\"Ramimize 1 bitlik veri saklama işini gerçekleştirecek temel RAM Hücresi. İç planı ve dışarıya soyutlanmış halleri.\">\n<br> <em>Ramimize 1 bitlik veri saklama işini gerçekleştirecek temel RAM Hücresi. İç planı ve dışarıya soyutlanmış halleri.</em></p>\n<p>Hücremizin içinde kullandığımız devrede ilginç bir eleman görebilirsiniz. <em>(D Q ve CLK yazan)</em></p>\n<p>Bu eleman ilk derste gösterdiğim <strong>AND-OR-LATCHE</strong> yani Ve-Veya Mandalı’nın birazcık daha değişik hali.</p>\n<blockquote>\n<p>Ve-Veya mandalı <strong>SET</strong> kısmına 1 verilince verimiz <strong>1</strong>\n<strong>Reset</strong> kısmına 1 verilince verimiz <strong>0</strong> oluyordu.</p>\n</blockquote>\n<p>Biz ise Set-Reset mantığı yerine,<strong>hangi veriyi verirsek onu saklayan</strong> bir mandal <em>( veya daha gelişmişi: Flip/Flop )</em> istiyoruz.</p>\n<p><strong>D-Tipi</strong> Flip Floplar da bu görevi gerçekleştiriyor.</p>\n<p>Merak etmeyin, baştaki mandalımıza <strong>2 VE</strong> ve <strong>1 Değil</strong> kapısı ekleyerek D-Tipi F/F elde edebiliriz.</p>\n<p>Logisim programında tasarladığım çalışan bir D-Tipi F/F’nin görüntüsü şu şekilde: <em>(yani RAM hücremizin içindeki D Q ve CLK yazan devre elemanının içi)</em></p>\n<p><img src=\"static/img/ram/logisim-d-ff.png\" alt=\"D-Tipi F/F iç devresi\"> <br>\n<a href=\"https://shorturl.at/kyDOY\">Logisim programında çalışan bir D tipi F/F devre dosyası</a></p>\n<blockquote>\n<p>Kırmızı çizgi ile ayırdığım kısmın sağında kalan parçalar ilk dersimizdeki <strong>Ve-Veya</strong> mandalı. Ek olarak sadece soldaki <strong>2 tane VE, 1 tane Değil</strong> kapılarını ekledik.</p>\n</blockquote>\n<p><strong>Bu bağlantıları neye göre yapacağımızı</strong> ve hangi kapıları ekleyeceğimizi D-Tipi F/F’lerin doğruluk tablosunu çizerek kendiniz de elde edebilirsiniz. <em>(ipucu olarak Data ve CLK girişlerine karşılık Set ve Reset çıkışlarının durumları tablosunu kullanarak devreyi elde edebilirsiniz.)</em></p>\n<h2>RAM Hücremiz tamam. Hadi şimdi bununla bir RAM yapalım!</h2>\n<p>Bu yazı hem biraz uzun oldu, hem de RAM’in direkt olarak iç dizaynını ayrı bir yazıda ele almak amacıyla <em>(tüm her şey tek bir yazıda toplanıp çorba gibi olmasın, ayrı ayrı düzenli olsun)</em> en iyisi bir sonraki yazıya bırakalım :)</p>\n<p>Serimizin son yazısı olacağını tahmin ettiğim <a href=\"0-dan-ram-6-ve-ram\">0 → RAM | 6) Ve RAM!</a> Yazımızda görüşmek üzere.</p>\n<p>Esenlikler ve mutluluklar içinde kalınız.<br>\nSelamün aleyküm.</p>","id":"b18792b7-1dc2-5bcc-8e8f-be868cc1ed80","frontmatter":{"date":"Mart 06, 2020","description":"Temel RAM bileşenlerimizin sonuncusu \"Kod Çözücüler\"","image":"static/img/ram/kapak-ram5.png","path":"/0-dan-ram-5-ram-hucresi","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 5) RAM Hücresi"}}}}}