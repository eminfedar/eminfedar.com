{"componentChunkName":"component---src-templates-blog-post-js","path":"/0-dan-ram-5-ram-hucresi","result":{"data":{"markdownRemark":{"html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizin iç devresini tasarlamaya başlayacağız. Atacağım devre dosyaları <a href=\"https://sourceforge.net/projects/circuit/\"><strong>Logisim</strong></a> programından olacak. Tamamen sıfırdan kendi RAM’inizi inşa edip, simüle edip test edebileceksiniz :)</p>\n<h2>RAM’imiz nasıl bir şey olacak?</h2>\n<p>RAM’imizin iç devresini tasarlamadan önce içi hazır bir eleman olarak düşünüp sadece giriş ve çıkışlarını tasarlayalım. <strong>Yani genel hatlarını belli edelim.</strong></p>\n<p>RAM’imiz <strong>2⁸x8</strong> boyutlarında olacak. Buradaki ilk değer RAM’in içindeki <strong>hücre</strong> sayısıdır. Yani 2⁸ tane <strong>çekmeceden</strong> oluşan bir dolap gibi düşünülebilir.</p>\n<p>İkinci değer (8) ise her çekmecenin içinde saklanan bit sayısıdır.</p>\n<p>Yani 2⁸=256 tane hücremiz var, her hücrede de 8 bit saklıyoruz.</p>\n<blockquote>\n<p>Dolayısıyla RAM’imiz <strong>2048</strong> adet <strong>0</strong> veya <strong>1</strong> saklıyor\n<strong>8 bit = 1 byte</strong> olduğundan <strong>256 Byte</strong>’lık bir RAM’imiz olacak.</p>\n</blockquote>\n<p>Eğer 1GB’lık bir RAM yapmak isteseydik:</p>\n<p><strong>1GB için 2³⁰x8</strong><br>\n<strong>2GB için 2³¹x8</strong><br>\n<strong>4GB için 2³²x8</strong>\nbir RAM tasarlayacaktık.</p>\n<p>32 bit işlemcilerin olduğu sistemlere 4GB’dan fazla RAM <strong>takılamamasının</strong> sebebi en fazla <strong>2 üzeri 32'ye</strong> kadar adres tutabilmesidir. Yani 2³²’den ekstra 1 tanecik fazla da olsa hücreyi adresleyemez, veriyi saklayamaz, tanımlayamaz, saklaması için 33. yeni bir bite ihtiyacı var.</p>\n<p>64 bit sistemler ise 2⁶⁴ yani <strong>“18 446 744 073 709 551 616 Byte”</strong> hafızaya sahip olacak kadar adresleme yapabilir, bu da yaklaşık <strong>“17 179 869 184 GB”</strong> yapıyor :) <em>(4GB’ye göre gerçekten yüksek bir rakam)</em></p>\n<blockquote>\n<p>Yani 64 bit işlemciye sahip bir bilgisayarınız varsa 17 Milyar GB RAM’e kadar yükseltme yapabilirsiniz (tabi gerçek hayatta adres tutmak için 64 bitin hepsi ayrılmaz :))</p>\n</blockquote>\n<h3>RAM Çipimizin Genel Tasarımı</h3>\n<p><img src=\"static/img/ram/ram-chip.png\" alt=\"RAM Çipimizin Genel Tasarımı.\"></p>\n<p><em>RAM Çipimizin Genel Tasarımı.</em></p>\n<p><strong>Y:</strong> Yüksek Değerlikli Bit (<strong>2⁷</strong>)<br>\n<strong>D:</strong> Düşük Değerlikli Bit (<strong>2⁰</strong>)<br>\n<strong>CS (Chip Select):</strong> RAM çipimizi aktif eden giriş.<br>\n<strong>R’/W:</strong> Okuma yapmak için <strong>0 (R’)</strong> Yazma yapmak için <strong>1 (W)</strong> değeri verilmesi gereken girişimiz.</p>\n<p>--</p>\n<p>Çipimiz tamam, peki işlemci ile veri alışverişini nasıl sağlayacak? Çıkışları direk işlemciye mi bağlayacağız? Eğer öyle ise her yaptığımız eleman için işlemcide ayrı ayrı çıkışların mı olması gerek?</p>\n<h3>Veri Aktarım Yöntemi</h3>\n<p>Normal şartlarda iki şekilde bir çipi başka bir çip ile haberleştirebilirsiniz:</p>\n<p><strong>1.</strong> Direkt olarak birinin <strong>çıkışlarını</strong> diğerinin <strong>girişlerine</strong> bağlarsınız</p>\n<p><strong>2.</strong> İki veya daha fazla çipi ortak bir tane veri yoluna bağlayıp, <strong>Çip Seçim</strong> girişleri ile sadece konuşturmak istediğiniz çipleri aktif ederek veri aktarımını sağlarsınız.</p>\n<p><em>(Örneğin SSD’den veri okuyacağım, o zaman SSD’yi aktif edip diğerlerini pasif halde tutarım. Veya RAM’den veri okumak istiyorum, diğerlerini pasif hale getirip bu sefer de sadece RAM’i aktif ederim)</em></p>\n<p><img src=\"static/img/ram/common-data-bus.gif\" alt=\"Ortak veri yolu kullanan çiplerin Chip Select girişi kullanılarak veri yoluna bağlanması.\">\n<br><em>Ortak veri yolu kullanan çiplerin Chip Select girişi kullanılarak veri yoluna bağlanması.</em></p>\n<h2>Gelelim artık RAM Hücresine!</h2>\n<p>Güzel bir söz var:</p>\n<blockquote>\n<p><strong>\"Baharı icad etmeyen, bir elmayı icad edemez. Zira o elma, o tezgâhta dokunuyor. Bir elmayı icad eden, bir baharı icad edebilir…\"</strong></p>\n</blockquote>\n<p>Bunun RAM ile alakası ise;</p>\n<blockquote>\n<p>Milyarlarca biti saklayabilmek için önce 1 biti saklayabilmek gerek,\n1 biti saklayamayan milyarları saklayamaz.\nMilyarları saklayabilen 1 biti saklayabilendir.</p>\n</blockquote>\n<p>Yani önce <strong>tek bir biti saklayabilen</strong> bir <strong>“RAM Hücresi”</strong> yapıp sonra bunu istediğimiz sayıda kopyalarak istediğimiz boyutta RAM elde edeceğiz.</p>\n<p><img src=\"static/img/ram/ram-cell.gif\" alt=\"Ramimize 1 bitlik veri saklama işini gerçekleştirecek temel RAM Hücresi. İç planı ve dışarıya soyutlanmış halleri.\">\n<br> <em>Ramimize 1 bitlik veri saklama işini gerçekleştirecek temel RAM Hücresi. İç planı ve dışarıya soyutlanmış halleri.</em></p>\n<p>Hücremizin içinde kullandığımız devrede ilginç bir eleman görebilirsiniz. <em>(D Q ve CLK yazan)</em></p>\n<p>Bu eleman ilk derste gösterdiğim <strong>AND-OR-LATCHE</strong> yani Ve-Veya Mandalı’nın birazcık daha değişik hali.</p>\n<blockquote>\n<p>Ve-Veya mandalı <strong>SET</strong> kısmına 1 verilince verimiz <strong>1</strong>\n<strong>Reset</strong> kısmına 1 verilince verimiz <strong>0</strong> oluyordu.</p>\n</blockquote>\n<p>Biz ise Set-Reset mantığı yerine,<strong>hangi veriyi verirsek onu saklayan</strong> bir mandal <em>( veya daha gelişmişi: Flip/Flop )</em> istiyoruz.</p>\n<p><strong>D-Tipi</strong> Flip Floplar da bu görevi gerçekleştiriyor.</p>\n<p>Merak etmeyin, baştaki mandalımıza <strong>2 VE</strong> ve <strong>1 Değil</strong> kapısı ekleyerek D-Tipi F/F elde edebiliriz.</p>\n<p>Logisim programında tasarladığım çalışan bir D-Tipi F/F’nin görüntüsü şu şekilde: <em>(yani RAM hücremizin içindeki D Q ve CLK yazan devre elemanının içi)</em></p>\n<p><img src=\"static/img/ram/logisim-d-ff.png\" alt=\"D-Tipi F/F iç devresi\"> <br>\n<a href=\"https://shorturl.at/kyDOY\">Logisim programında çalışan bir D tipi F/F devre dosyası</a></p>\n<blockquote>\n<p>Kırmızı çizgi ile ayırdığım kısmın sağında kalan parçalar ilk dersimizdeki <strong>Ve-Veya</strong> mandalı. Ek olarak sadece soldaki <strong>2 tane VE, 1 tane Değil</strong> kapılarını ekledik.</p>\n</blockquote>\n<p><strong>Bu bağlantıları neye göre yapacağımızı</strong> ve hangi kapıları ekleyeceğimizi D-Tipi F/F’lerin doğruluk tablosunu çizerek kendiniz de elde edebilirsiniz. <em>(ipucu olarak Data ve CLK girişlerine karşılık Set ve Reset çıkışlarının durumları tablosunu kullanarak devreyi elde edebilirsiniz.)</em></p>\n<h2>RAM Hücremiz tamam. Hadi şimdi bununla bir RAM yapalım!</h2>\n<p>Bu yazı hem biraz uzun oldu, hem de RAM’in direkt olarak iç dizaynını ayrı bir yazıda ele almak amacıyla <em>(tüm her şey tek bir yazıda toplanıp çorba gibi olmasın, ayrı ayrı düzenli olsun)</em> en iyisi bir sonraki yazıya bırakalım :)</p>\n<p>Serimizin son yazısı olacağını tahmin ettiğim <a href=\"0-dan-ram-6-ve-ram\">0 → RAM | 6) Ve RAM!</a> Yazımızda görüşmek üzere.</p>\n<p>Esenlikler ve mutluluklar içinde kalınız.<br>\nSelamün aleyküm.</p>","frontmatter":{"date":"Mart 06, 2020","image":"static/img/ram/kapak-ram5.png","path":"/0-dan-ram-5-ram-hucresi","tags":["RAM"],"title":"0 → RAM | 5) RAM Hücresi"}}},"pageContext":{"slug":"/0-dan-ram-5-ram-hucresi","previous":{"excerpt":"Merhabalar! Bu yazımızda RAM’imizin içindeki belirli adreslere erişmek için devremizde kullanacağımız Kod Çözücüleri ve Kodlayıcıları ele alacağız. Kod Çözücüler ne işe yarar? Bir Kod Çözücü kısaca…","html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizin içindeki belirli adreslere erişmek için devremizde kullanacağımız <strong>Kod Çözücüleri</strong> ve <strong>Kodlayıcıları</strong> ele alacağız.</p>\n<h2>Kod Çözücüler ne işe yarar?</h2>\n<p>Bir Kod Çözücü kısaca: <strong>seçim elemanıdır.</strong></p>\n<p>Girişlerine ikilik tabanda verilen girdiye göre sadece bir çıkışını aktif eder. Örneğin <strong>2 girişli</strong> ve <strong>4 çıkışlı</strong> (2x4) bir Kod Çözücü aşağıdaki gibi çalışır:</p>\n<blockquote>\n<p>00 -> <strong>0</strong></p>\n<p>01 -> <strong>1</strong></p>\n<p>10 -> <strong>2</strong></p>\n<p>11 -> <strong>3</strong></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*XHlRexbJWrW9BobgAUxDtQ.gif\" alt=\"2 Giriş, 4 Çıkışlı bir kod çözücünün çalışma şekli.\"></p>\n<p><em>2 Giriş, 4 Çıkışlı bir kod çözücünün çalışma şekli.</em></p>\n<p>Gördüğünüz gibi burada decoderin(kod çözücünün) iç devre tasarımı yok, bize sadece giriş ve çıkış uçları olan bir devre elemanı olarak verilmiş.</p>\n<p>Bu olaya <strong>abstraction</strong> yani <strong>soyutlama</strong> denir.</p>\n<p>Çoğu zaman yaptığımız ve bir işlevi gerçekleştirebilen küçük devreleri her seferinde tekrardan çizmeyiz. Bir kere çizdikten sonra onları bir eleman haline getirip sonra çoğaltarak istediğimiz kadar kullanırız. <em>(Bu düstur yazılımda da sıkça kullanılmaktadır)</em></p>\n<p>Fakat biz yine de kendi decoderimizi de yapmayı öğrenebilmek adına içine bir göz atalım :)</p>\n<p><em>Aslında gayet basit bir iç devresi var.</em></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*N3XCDp5dOmWpUfCdqYm0Hg.gif\" alt=\"2x4 Kod Çözücünün içi.\"><em>2x4 Kod Çözücünün içi.</em></p>\n<p>Siz de kolayca çıkışlarımızın mantıksal durumlarını yazarak devreyi rahatlıkla bulabilirdiniz. Nitekim biz de öyle yaptık:</p>\n<blockquote>\n<p>Y0= X1’.X0’ (00)</p>\n<p>Y1= X1’.X0 (01)</p>\n<p>Y2= X1.X0’ (10)</p>\n<p>Y3= X1.X0 (11)</p>\n</blockquote>\n<h3>“İyi güzel de, bu RAM yaparken ne işimize yarayacak?”</h3>\n<p>Eğer yazılım ile uğraşıyorsanız, özellikle C/C++ gibi adreslemelerin <em>(pointer)</em> bolca kullanıldığı dillerde tanımladığınız <strong>değişkenlerin</strong> bir <strong>adresi</strong> olduğunu fark etmişsinizdir.</p>\n<p>Bu adres genelde <strong>0x123456</strong> şeklinde onaltılık tabanda gösterilen bir sayı olur ve değişkeninizdeki <strong>verinin</strong> RAMinizde 0x123456 nolu bellek hücresinde tutulduğunu belirtir.</p>\n<h3>Mesela:</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*ZUdJocmCbepWUyJnPSk-5w.png\" alt=\"a isminde bir değişkenin RAM’deki bir hücrede saklanması.\"></p>\n<p><em>a isminde bir değişkenin RAM’deki bir hücrede saklanması.</em></p>\n<h3>İşte tam burada kod çözücüler devreye giriyor.</h3>\n<p>Bilgisayarda tüm işlemlerimiz İkilik (Binary) sistemde, yani 0 veya 1.</p>\n<p>0x100002 nolu hücreye erişebilmek için <strong>örneğin 4GB</strong>’lik bir RAM’de <strong>4,294,967,296</strong> tane hücreden <strong>sadece 1 tanesini</strong> seçip okumamız/yazmamız gerek ve bunu ikilik sistemde çalışan işlemcimizden aldığımız bitler ile yapabilmeliyiz.</p>\n<p>Kod Çözücüler ise seçim elemanlarıydı ve tam da aradığımız gibi; girişlerine ikilik sistemden bir sayı alıp, çıkışlarından sadece o sayıya karşılık gelen çıkışı aktif hale getiriyordu.</p>\n<p>Bu şekilde eğer bir Kod çözücüye <strong>2³² = 4,294,967,296</strong> hesabıyla <strong>32 giriş</strong> ve <strong>4,294,967,296</strong> farklı çıkış verirsek tüm hücrelere rahatlıkla erişebiliriz değil mi?</p>\n<h3>Aslında pek de sayılmaz :)</h3>\n<p>4,294,967,296 tane kabloyu teker teker bir hücreye bağlamak hem kablo, hem alan hem de işlem israfı olacaktır. Bu yüzden tek boyutlu olarak düşündüğümüz hücreleri adresleme işlemini iki boyutlu düşünmeliyiz. Yani 1 boyutlu bir dizi değil de, 2 boyutlu bir Matris olarak hücrelerimizi tutmalıyız.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*-KvuViSro2avKO3wtKrXww.gif\" alt=\"2 boyutlu matris kullanarak daha az kablo kullanımını sağlamak.\"><em>2 boyutlu matris kullanarak daha az kablo kullanımını sağlamak.</em></p>\n<p>4GB’lik bir RAM için ise 2³² şeklinde tek bir decoder yerine, 2⁸’lik 4 tane decoder kullanılabilir. Böylece kablo sayısı 4,294,967,296'dan 128'e düşüyor. Bu da bize <strong>33 milyon kat</strong> daha az kablo kullanımı ile muazzam bir tasarruf sağlıyor.</p>\n<h2>Kod çözücüler de tamam!</h2>\n<p>Artık RAM yapabilmek için temel bileşenlerin çoğunun çalışma şeklini biliyoruz.</p>\n<p>Şimdi geriye bu bileşenleri kullanarak bir RAM tasarlamak kaldı.</p>\n<p>Bir sonraki yazımız olan <strong><a href=\"0-dan-ram-5-ram-hucresi\">0 → RAM | 5) RAM Hücresi</a></strong>'inde görüşmek üzere!</p>","id":"46b74bd1-d671-5a63-8562-d70a94ae6ec4","frontmatter":{"date":"Mart 05, 2020","description":"Temel RAM bileşenlerimizin sonuncusu \"Kod Çözücüler\"","image":"static/img/ram/kapak-ram4.png","path":"/0-dan-ram-4-kod-cozuculer","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 4) Kod Çözücüler"}},"next":{"excerpt":"Merhabalar! Bu yazımızda RAM’imizi tasarlamayı bitiriyoruz. Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efenim. Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efendim. RAM…","html":"<h2>Merhabalar!</h2>\n<p>Bu yazımızda RAM’imizi tasarlamayı bitiriyoruz.</p>\n<p><img src=\"static/img/ram/buzz-eriste.jpeg\" alt=\"Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efenim.\"> <br><em>Az kalorili ve rastgele erişteli belleğimiz yemeye hazır efendim.</em></p>\n<h2>RAM’imizin içini adım adım tasarlayalım:</h2>\n<ol>\n<li>Adres girişlerinden aldığımız sayıyı 4. Yazıda ele aldığımız <a href=\"0-dan-ram-4-kod-cozuculer\">Kod Çözücüleri</a> kullanarak iki boyutlu <a href=\"0-dan-ram-5-ram-hucresi\">Ram Hücreleri</a> matrisi hazırlayalım.</li>\n<li>Bu matrisin içine hücrelerimizi yerleştirip hücrenin “<strong>EN</strong>”<em>(aktif etme)</em> ucunu iki kod çözücüden gelen seçim uçlarına “<strong>VE</strong>” kapısı ile bağlayacağız. *(Mesela <strong>0. satır</strong> ve <strong>4. sütun</strong> seçim uçları <strong>aktif ise</strong> (0, 4)'teki hücreyi aktif et)*</li>\n<li>RAM’e erişimin okumak için mi yazmak için mi olduğunu öğrendiğimiz <strong>R/W’</strong> girişini bütün <strong>hücrelerin R/W</strong>’ girişlerine <strong>teker teker</strong> bağlayacağız.</li>\n<li>Seçtiğimiz RAM hücresinden veriyi okuyacağımız veya yazacağımız pin olan <strong>I/O</strong> (Giriş/Çıkış) pinini de bütün <strong>hücrelerin I/O</strong> girişine bağlayacağız.</li>\n<li>Chip Select girişini ise direkt olarak bütün girişlerle VE kapılayabiliriz ama bu biraz uzun ve gereksiz bir uğraş olur gibi.\nOnun yerine; eğer gerçekten yapacak olsaydık, decoder gibi komponentlerimizin VCC ve GND uçları olacağından sadece VCC uçlarını VE kapılayabilirdik. <em>(yani çipe elektriği verip vermeme şeklinde bir anahtarlama olabilir.)</em>\n<em>(O yüzden CS pini görselde bir yere bağlı değil :))</em></li>\n</ol>\n<p><img src=\"static/img/ram/ram-full.png\" alt=\"4000x4000 çözünürlüğe sahip RAMcik içi.\">\n<br><em>4000x4000 çözünürlüğe sahip RAMcik içi.</em></p>\n<p>Bütün bunları sırasıyla yaptığımızda karşımızda RAM’imiz için 8 tanesini yan yana getireceğimiz 256 boyutunda 1 bit saklayabilen <strong>“RAMcik”</strong>leri elde ederiz :).</p>\n<p>(😲)</p>\n<div style=\"width: 100%; height: 0px; position: relative; padding-bottom: 100.000%;\"><iframe src=\"https://streamable.com/s/xwc8s/nrcvlh\" frameborder=\"0\" width=\"100%\" height=\"100%\" allowfullscreen style=\"width: 100%; height: 100%; position: absolute;\"></iframe></div>\n<p><a href=\"https://streamable.com/xwc8s\">> HD Video</a></p>\n<p>Şema olarak RAM’imizden tek farkı veri çıkışında sadece 1 tane pin olması. <em>(Çünkü 256 farklı adres için sadece 1 bit saklayan hücrelerden oluşuyor)</em></p>\n<p>Bu 256 farklı adreste 1 bit saklayan “RAMcik”lerimizden 8 tane yan yana getirip, veri çıkışlarını da yüksek önemli bitten düşük önemli bite göre bağlayıp CS ve R’/W uçlarını da RAM’in CS ve R’/W uçlarına bağlar isek, 256x8'lik bir RAM yapmış oluruz.</p>\n<p><img src=\"static/img/ram/ram-son-hal.gif\" alt=\"Ve RAM!\"></p>\n<h2>Ve RAM!</h2>\n<p>Tebrikler!</p>\n<p>6 yazılık bu bloğu okuyup anlayarak kendi RAM’inizi sıfırdan tasarlamayı öğrendiniz. <em>(her yiğidin harcı değil )</em></p>\n<p><img src=\"static/img/ram/congrats.jpeg\" alt=\"Tebrikler!\"><br><em>Tebrikler!</em></p>\n<blockquote>\n<p>Eğer babanızdan kalma fabrika zincirleriniz varsa veya milyoner bir iş adamıysanız bu bilgiler üzerine biraz daha koyarak (256 Byte yetmez şimdi tabi, bunu nano seviyede küçültüp 8GB yi sığdırmanız lazım oraya :)) gerçek ve elle tutulur bir RAM yapıp ülkeye güzel bir ihracat geliri getirebilirsiniz :)</p>\n</blockquote>\n<p>Veya kişisel çaplı projelerde kullanılmak üzere (mesela bir arduino projesi) modül olarak takılabilir bir RAM yapıp insanlara sunabilirsiniz. <em>(veya satabilirsiniz :))</em></p>\n<blockquote>\n<p>Tabi bu işin de kendince standartları var, bizim yaptığımız RAM tamamen kendi standartlarımız ve tercihlerimize dayalı oldu.</p>\n</blockquote>\n<h2>Bundan Sonra</h2>\n<p>Daha da derinlere inip bu işin ehli olmak isterseniz inceleyebileceğiniz birkaç wikipedia linki ekleyelim:</p>\n<p>RAM çeşitleri olarak <a href=\"https://www.wikiwand.com/en/Static_random-access_memory\">SRAM</a>, <a href=\"https://www.wikiwand.com/en/Dynamic_random-access_memory\">DRAM</a>.\n<em>(RAM var RAM var, hepsi aynı değil tabi)</em></p>\n<p>İşlemci ile RAM’in arasındaki iletişim standartları olarak ise<a href=\"https://www.wikiwand.com/en/Double_data_rate\"> SDR, DDR, QDR</a> gibi konulara bakabilirsiniz.\n<em>(Gözünüz korkmasın, bunlar sadece belirli standartlar, çok farklı ve gelişmiş şeyler değil, buraya kadar geldiyseniz bunları da kolayca anlayabilirsiniz.)</em></p>\n<p>Günleriniz ve ömrünüz bol bereketli ve hayırlı olsun.\n<br> <strong>İyi günler.</strong></p>","id":"cce30859-a23d-5d5c-bee0-6adb5f5ab6c3","frontmatter":{"date":"Mart 07, 2020","description":"Ve RAM'imizin son hali :)","image":"static/img/ram/kapak-ram6.png","path":"/0-dan-ram-6-ram-hucresi","tags":["RAM"],"templateKey":"blog-post","title":"0 → RAM | 6) Ve RAM!"}}}}}